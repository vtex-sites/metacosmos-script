{"version":3,"file":"Floating.7a2454b2.js","sources":["../../src/lib/elements/utils/click-outside.ts","../../src/lib/elements/utils/portal.ts","../../node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","../../src/lib/elements/Floating/platform.ts","../../src/lib/elements/Floating/Floating.svelte"],"sourcesContent":["/// <reference path=\"./click-outside.d.ts\" />\n\n// Adopted from https://svelte.dev/repl/0ace7a508bd843b798ae599940a91783?version=3.16.7\n// the `ownerDocument` allows to use the action across Realms\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/ownerDocument\nexport const clickOutside = (node: Node, bounding: Node | ShadowRoot = node.ownerDocument!) => {\n  const handleClick = (event: Event) => {\n    if (node && !node.contains(event.target as Node) && !event.defaultPrevented)\n      node.dispatchEvent(new CustomEvent(\"click_outside\", node as CustomEventInit))\n  }\n\n  bounding.addEventListener(\"click\", handleClick, true)\n\n  return {\n    destroy: () => bounding.removeEventListener(\"click\", handleClick, true),\n  }\n}\n","/**\n * Borrowed idea from https://github.com/romkor/svelte-portal/blob/master/src/Portal.svelte\n *\n * Unfortunately, the referenced package can not be used directly in the app,\n * since it uses `instanceof HTMLElement` check (https://github.com/romkor/svelte-portal/blob/master/src/Portal.svelte#L25).\n * The check does not play well with Realms (see @lib/widget for detail on the Realm).\n * If the action runs inside a Realm and it tries to teleport an `element` to a `target` located outside of the Realm,\n * e.g `target` is located at the main Document element,\n * the `instanceof` check will fail since built-ins like HTMLElement are different between the Real and outside Realm/Document.\n * In simple words, Realm.HTMLElement !== Document.HTMLElement.\n * Thus, we have to write the action ourselves, omitting the `instanceof` check.\n */\n\n/**\n * Usage: <div use:portal={document.body}>\n *\n * @param {HTMLElement} element an HTML Element\n * @param {HTMLElement} target DOM Element\n */\nexport const portal = (element: HTMLElement, target: HTMLElement | ShadowRoot) => {\n  target.appendChild(element)\n\n  return {\n    update: (target: HTMLElement | ShadowRoot) => target.appendChild(element),\n    destroy: () => element.parentNode && element.parentNode.removeChild(element),\n  }\n}\n","function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset(middlewareArguments) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      await apply({ ...middlewareArguments,\n        ...dimensions\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (rects.floating.width !== nextDimensions.width || rects.floating.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import type { Rect } from \"@floating-ui/core\"\n\n/**\n * The default [platform](https://floating-ui.com/docs/platform) implementation of @floating-ui/dom\n * highly relies on `instanceof HTMLElement` checks, which do not play well with Realms (see @lib/widget for detail on the Realm).\n * To workaround the issue, we have to implement the `platform` binding ourselves.\n *\n * The code below is mainly inspired by https://github.com/floating-ui/floating-ui/blob/master/packages/dom/src/platform.ts\n * There are lots of admissions and simplifications to the original methods.\n */\n\nexport const getElementRects = ({\n  reference,\n  floating,\n}: {\n  reference: HTMLElement\n  floating: HTMLElement\n}) => ({\n  // https://github.com/floating-ui/floating-ui/blob/master/packages/dom/src/platform.ts#L18\n  reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating)!),\n  floating: { x: 0, y: 0, ...getDimensions(floating) } as Rect,\n})\n\nexport const getDimensions = (element: HTMLElement) => ({\n  width: element.offsetWidth,\n  height: element.offsetHeight,\n})\n\nexport const getClippingRect = ({ element }: { element: HTMLElement }) => {\n  /**\n   * Highly simplified version of https://github.com/floating-ui/floating-ui/blob/master/packages/dom/src/utils/getClippingRect.ts\n   * since we know the app renders all the floating elements to the app's root which mush have `position: relative`\n   */\n\n  return getOffsetParent(element)!.getBoundingClientRect() as Rect\n}\n\n/** Reverse operation to {@link getRectRelativeToOffsetParent} */\nexport const convertOffsetParentRelativeRectToViewportRelativeRect = ({\n  rect,\n  offsetParent,\n}: {\n  rect: Rect\n  offsetParent: HTMLElement\n}) => {\n  /**\n   * Simplified version of https://github.com/floating-ui/floating-ui/blob/master/packages/dom/src/utils/convertOffsetParentRelativeRectToViewportRelativeRect.ts\n   * which does not take into account root element scroll\n   */\n\n  const parentRect = offsetParent.getBoundingClientRect()\n\n  return {\n    ...rect,\n    x: rect.x + (parentRect.left + offsetParent.clientLeft),\n    y: rect.y + (parentRect.top + offsetParent.clientTop),\n  } as Rect\n}\n\nexport const getOffsetParent = (element: HTMLElement) => {\n  let offsetParent = element.offsetParent\n\n  if (!offsetParent)\n    while ((offsetParent = element.parentElement))\n      if (/(relative|absolute|fixed)/.test(getComputedStyle(offsetParent).position)) break\n\n  return offsetParent as null | HTMLElement\n}\n\nexport const getDocumentElement = (element: HTMLElement) => element.ownerDocument\n\nexport const getClientRects = (/* element: HTMLElement */) => {\n  /**\n   * The method is not currently used by any of @floating-ui/core middlewares the app consumes.\n   * Since the method is not used hence untested, it's better to throw an error for now,\n   * so future developers can notice it and test the method.\n   */\n\n  throw new Error(`The \"getClientRects\" is not implemented`)\n\n  /** Guessing that the code commented below should works just fine. */\n\n  // return [...element.getClientRects()]\n}\n\nexport const isElement = (obj: any): obj is HTMLElement => {\n  /**\n   * Realm-friendly check of obj being an instance of HTMLElement w/o usage of `instanceof` keyword\n   * Inspired by https://stackoverflow.com/a/384380\n   */\n  return obj && obj.nodeType === Node.ELEMENT_NODE && obj.style && obj.ownerDocument\n}\n\nexport const isRTL = () => {\n  /** Should be re-implemented once the app uses RTL layout (e.g arabic language) */\n\n  return false\n}\n\nconst getRectRelativeToOffsetParent = (element: HTMLElement, parent: HTMLElement) => {\n  /**\n   * Simplified version of https://github.com/floating-ui/floating-ui/blob/master/packages/dom/src/utils/getRectRelativeToOffsetParent.ts\n   * which does not take into account root element scroll\n   */\n\n  const elementRect = element.getBoundingClientRect()\n  const parentRect = parent.getBoundingClientRect()\n\n  return {\n    x: elementRect.left - (parentRect.left + parent.clientLeft),\n    y: elementRect.top - (parentRect.top + parent.clientTop),\n    width: elementRect.width,\n    height: elementRect.height,\n  } as Rect\n}\n","<!-- Base element for Popup, Tooltips, etc -->\n<script lang=\"ts\" context=\"module\">\n  import type { Placement as FloatingUIPlacement } from \"@floating-ui/core\"\n\n  type Placement =\n    | FloatingUIPlacement\n    | \"top-left-corner\"\n    | \"top-right-corner\"\n    | \"bottom-right-corner\"\n    | \"bottom-left-corner\"\n\n  export type { Placement }\n</script>\n\n<script lang=\"ts\">\n  import { type SvelteComponent, createEventDispatcher, onMount, tick } from \"svelte\"\n  import { sineInOut as easing } from \"svelte/easing\"\n  import { fade } from \"svelte/transition\"\n  import {\n    computePosition,\n    offset as offsetMiddleware,\n    shift as shiftMiddleware,\n    size as sizeMiddleware,\n  } from \"@floating-ui/core\"\n  import { clickOutside, getSvelteRoot, portal } from \"../utils\"\n  import * as platform from \"./platform\"\n\n  export let anchor: HTMLElement | SvelteComponent | undefined = undefined\n  export let placement: Placement = \"bottom\"\n  export let offset: [mainAxis: number, crossAxis: number] = [0, 0]\n\n  let trigger: HTMLElement | null = null\n  let popup: HTMLElement\n  const root = getSvelteRoot()\n  const dispatch = createEventDispatcher<{ open: void; close: void }>()\n\n  export const open = (anchor: HTMLElement) => (trigger = anchor)\n  export const close = () => (trigger = null)\n\n  $: dispatch(trigger ? \"open\" : \"close\")\n\n  $: tick() // wait for svelte to popuate the \"popup\" element refernce\n    .then(\n      () =>\n        trigger &&\n        computePosition(trigger, popup, {\n          platform,\n          strategy: \"absolute\",\n          placement: (placement.endsWith(\"-corner\")\n            ? placement.replace(\"-corner\", \"\").replace(\"left\", \"start\").replace(\"right\", \"end\")\n            : placement) as FloatingUIPlacement,\n          middleware: [\n            offsetMiddleware(({ rects }) => {\n              let [mainAxis, crossAxis] = offset\n\n              if (placement.endsWith(\"-corner\"))\n                if (/(left|right)/.test(placement))\n                  crossAxis += (/left/.test(placement) ? -1 : 1) * rects.floating.width\n\n              return { mainAxis, crossAxis }\n            }),\n            sizeMiddleware({\n              // TODO: somehow retrieve the boundary, i.e. the Widget's current page\n              // boundary: ? ,\n              apply: ({ availableHeight }) => {\n                Object.assign(popup.style, { maxHeight: `${availableHeight}px` })\n              },\n            }),\n            shiftMiddleware({ padding: 12 }),\n          ],\n        }).then(({ x, y }) => Object.assign(popup.style, { left: `${x}px`, top: `${y}px` }))\n    )\n\n  onMount(() => {\n    const p = (anchor ? Promise.resolve() : tick()) // wait for svelte to popuate the \"anchor\" element/component refernce\n      .then(() => {\n        if (!anchor) {\n          // looks like anchor was not provided\n          // and the Floating is going to be controlled externally via open / close methods\n          return () => {}\n        }\n\n        const isHTMLElement = anchor instanceof HTMLElement\n\n        const doOpen = ({ currentTarget }: MouseEvent) => open(currentTarget as HTMLElement)\n\n        return isHTMLElement\n          ? (anchor.addEventListener(\"click\", doOpen),\n            () => anchor!.removeEventListener(\"click\", doOpen))\n          : (anchor as SvelteComponent).$on(\"click\", doOpen)\n      })\n\n    return () => p.then((cleanup) => cleanup())\n  })\n</script>\n\n{#if trigger}\n  <div\n    class={$$restProps.class}\n    transition:fade|local={{ duration: 200, easing }}\n    use:portal={root}\n    use:clickOutside={root}\n    bind:this={popup}\n    on:click_outside={close}\n  >\n    <slot {close} />\n  </div>\n{/if}\n\n<style lang=\"postcss\">\n  div {\n    @apply absolute top-0 left-0 z-[99999999] flex flex-col;\n\n    & > :global(*) {\n      @apply min-h-0;\n    }\n  }\n</style>\n"],"names":["clickOutside","node","bounding","handleClick","event","portal","element","target","getSide","placement","getAlignment","getMainAxisFromPlacement","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","commonY","mainAxis","length","commonAlign","side","isVertical","coords","computePosition","config","strategy","middleware","platform","rects","x","y","statefulPlacement","middlewareData","resetCount","i","name","fn","nextX","nextY","data","reset","expandPaddingObject","padding","getSideObjectFromPadding","rectToClientRect","rect","detectOverflow","middlewareArguments","options","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","elementClientRect","min","max","within","min$1","value","max$1","convertValueToCoords","alignment","mainAxisMulti","crossAxisMulti","rawValue","crossAxis","alignmentAxis","offset","diffCoords","getCrossAxis","shift","checkMainAxis","checkCrossAxis","limiter","detectOverflowOptions","overflow","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","size","apply","heightSide","widthSide","xMin","xMax","yMin","yMax","dimensions","nextDimensions","getElementRects","getRectRelativeToOffsetParent","getOffsetParent","getDimensions","getClippingRect","convertOffsetParentRelativeRectToViewportRelativeRect","offsetParent","parentRect","getDocumentElement","getClientRects","isElement","obj","isRTL","parent","elementRect","attr","div","div_class_value","null_to_empty","ctx","insert","anchor","current","dirty","easing","create_if_block","$$props","trigger","popup","root","getSvelteRoot","dispatch","createEventDispatcher","open","$$invalidate","close","onMount","p","tick","isHTMLElement","doOpen","currentTarget","cleanup","$$value","offsetMiddleware","sizeMiddleware","availableHeight","shiftMiddleware"],"mappings":"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"}