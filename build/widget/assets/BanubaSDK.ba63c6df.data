For future versions
const assets = bnb.scene.getAssetManager()

const ContentMode = {
  /* 0 */ SCALE_TO_FILL: 0,
  /* 1 */ FILL: 1,
  /* 2 */ FIT: 2,
}

exports = new class Background {
  constructor() {
    const camera = assets.findImage("camera") || assets.findImage("camera_image")
    if (!camera) throw new Error("Unable to find 'camera' or 'camera_image' image which is mandatory")

    const proceduralTexture = camera.asProceduralTexture()
    if (!proceduralTexture)
      throw new Error(
        "The Background feature requires 'camera' image to be of type 'procedural_texture'",
      )
    const composer = proceduralTexture.asCameraComposer()

    this._background = composer
  }

  /**
   * Sets the background color
   * @param {string} color - "R G B A" color
   */
  color(color) {
    throw new Error("Background.color() in not implemented yet")
  }

  /**
   * Sets the background transparency from 0 to 1
   * @param {number} value - transparency value in [0, 1] range
   */
  transparency(value) {
    this._background.setTransparencyFactor(1 - value)
  }

  /**
   * Sets the file (image or video) as background texture
   * @param {string|null} filename - path to the file to be loaded
   * @param {boolean} play - play video after load finished
   * @param {boolean} loop - loop video playback
   */
  texture(filename, play = true, loop = true) {
    this._background.setBackgroundImage(filename || "", play, loop)
  }

  /**
   * Sets the file (image) as background texture
   * @param {int} fd - file descriptor
   */
  textureImageByFd(fd) {
    this._background.setBackgroundImageByFd(fd)
  }

  /**
   * Sets the file (video) as background texture
   * @param {int} fd - file descriptor
   * @param {boolean} play - play video after load finished
   * @param {boolean} loop - loop video playback
   */
  textureVideoByFd(fd, play = true, loop = true) {
    this._background.setBackgroundVideoByFd(fd, play, loop)
  }

  /**
   * Rotates the background texture clockwise in degrees
   * @param {number} angle - rotation angle in degrees
   */
  rotation(angle) {
    this._background.setRotation(-angle)
  }

  /**
   * Scales the background texture
   * @param {number} factor - scale factor
   */
  scale(factor) {
    this._background.setScale(factor, factor)
  }

  /**
   * Sets the texture content mode
   * @param {"scale_to_fill" | "fill" | "fit"} mode - content mode
   */
  contentMode(mode) {
    this._background.setContentMode(ContentMode[mode.toUpperCase()])
  }

  /**
   * Sets the background blur radius
   * @param {number} [radius=0.2] - blur radius in [0, 1] range
   */
  blur(radius = 0.2) {
    radius *= 10
    this._background.enableBlur(radius > 0)
    this._background.setBlurRadius(radius)
  }

  /**
   * Sets the Bokeh blur radius
   * @param {number} radius - Bokeh blur radius
   */
  bokeh(radius = 1) {
    throw new Error("Background.bokeh() in not implemented yet")
  }

  /**
   * Access to underlying video object 
   */
  getBackgroundVideo() {
      return this._background.getBackgroundVideo()
  }

  /** Removes the background color and texture, resets any settings applied */
  clear() {
    // this.color("0 0 0 0")
    this.transparency(0)
    this.texture(null)
    this.rotation(0)
    this.scale(1)
    this.contentMode("fill")
    this.blur(0)
    // this.bokeh(0)
  }
}
require("./global")

/**
 * Polyfill for browser's
 *
 * console.log
 * console.info
 * console.warn
 * console.error
 */

/***/

/** @param {...*} data */
const log = (...data) => {
  const str = data.map(String).join(" ")
  bnb.log(str)
}

const console = {
  info: log.bind(null, "\n[Console.INFO]"),
  log: log.bind(null, "\n[Console.LOG]"),
  warn: log.bind(null, "\n[Console.WARN]"),
  error: log.bind(null, "\n[Console.ERROR]"),
}

// JSC has it's own dummy `console`, overwrite it
if (globalThis.console !== console) {
  globalThis.console = console
}
/** 
 * globalThis polyfill for MacOS/iOS Safari < 14
 * @see https://wiki.duktape.org/howtoglobalobjectreference
 */
if (typeof globalThis === "undefined") {
    const globalThis = new Function("return this")()
    Object.defineProperty(globalThis, "globalThis", {
        value: globalThis,
        writable: true,
        enumerable: false,
        configurable: true,
    })
}

/**
 * Legacy Banuba SDK scripting support. 
 * https://docs.banuba.com/face-ar-sdk/effect_constructor/reference/config_js
 */

var getFRXVersion = bnb.RenderInfo.getFrxVersion
var getPlatform = bnb.RenderInfo.getPlatform

var meshfxApi = bnb.meshfxApi

function getCurrentTimeNs()
{
    return meshfxApi.getCurrentTimeNs()
}

function print(msg)
{
    return meshfxApi.print(msg)
}

function meshfxMsg(tag, instanceId, index = 0, param = "")
{
    return meshfxApi.meshfxMsg(tag, instanceId, index, param)
}

function meshfxReset()
{
    return meshfxApi.meshfxReset()
}

function playVideo(layerId, isLooped, speedFactor)
{
    return meshfxApi.playVideo(layerId, isLooped, speedFactor)
}


function playVideoRange(layerId, startTime, stopTime, isLooped, speedFactor)
{
    return meshfxApi.playVideoRange(layerId, startTime, stopTime, isLooped, speedFactor)
}

function pauseVideo(layerId)
{
    return meshfxApi.pauseVideo(layerId)
}

function stopVideo(layerId)
{
    return meshfxApi.stopVideo(layerId)
}

function seekVideo(layerId, time)
{
    // unimplemented
}

function getCurrentVideoTime(layerId)
{
    // unimplemented
    return 0
}

function getVideoDuration(layerId)
{
    // unimplemented
    return 0
}

function setVideoVolume(layerId, volume)
{
    // unimplemented
}

function getVideoVolume(layerId)
{
    return 0.0
}

function recordStart(maximumDuration)
{
    // unimplemented
}

function recordStop()
{
    // unimplemented
}

function playSound(filename, isLooped, speedFactor)
{
    return meshfxApi.playSound(filename, isLooped, speedFactor)
}

function playSoundRange(filename, startTime, stopTime, isLooped, speedFactor)
{
    return meshfxApi.playSoundRange(filename, startTime, stopTime, speedFactor)
}

function stopSound(filename)
{
    return meshfxApi.stopSound(filename)
}

function pauseSound(filename)
{
    return meshfxApi.pauseSound(filename)
}

function seekSound(filename, time)
{
    // unimplemented
}

function getCurrentSoundTime(filename)
{
    // unimplemented
    return 0
}

function getSoundDuration(filename)
{
    return 0
}

function setSoundVolume(filename, volume) {
    meshfxApi.setSoundVolume(filename, volume)
}

function showRecordButton()
{
    // unimplemented
}

function hideRecordButton()
{
    // umimplemented
}

function showHint(hint)
{
    // unimplemented
}

function hideHint()
{
    // unimplemented
}

function drawingAreaWidth()
{
    return meshfxApi.drawingAreaWidth()
}

function drawingAreaHeight()
{
    return meshfxApi.drawingAreaHeight()
}


function visibleAreaWidth()
{
    return meshfxApi.visibleAreaWidth()
}


function visibleAreaHeight()
{
    return meshfxApi.visibleAreaHeight()
}


function effectEvent(name, params)
{
    return meshfxApi.effectEvent(name, params)
}

function setRecognizerFeatures(features)
{
    return meshfxApi.setRecognizerFeatures(features)
}

function isMouthOpen()
{
    return meshfxApi.isMouthOpen()    
}

function isSmile()
{
    return meshfxApi.isSmile()
}

function isEyebrowUp()
{
    return meshfxApi.isEyebrowUp()
}

function isDisgust()
{
    return meshfxApi.isEyebrowUp()
}

function getEyesStatus()
{
    return meshfxApi.getEyesStatus()
}


function getNamedState(name)
{
    return meshfxApi.getNamedState(name)
}


function isMirrored()
{
    return meshfxApi.isMirrored()
}


function getRotationVector()
{
    return meshfxApi.getRotationVector()
}

function modelview()
{
    return meshfxApi.modelview()
}

exports = {
    getFRXVersion,
    getPlatform,
    getCurrentTimeNs,
    print,
    meshfxMsg,
    meshfxReset,
    playVideo,
    playVideoRange,
    pauseVideo,
    stopVideo,
    seekVideo,
    getCurrentVideoTime,
    getVideoDuration,
    setVideoVolume,
    getVideoVolume,
    recordStart,
    recordStop,
    playSound,
    playSoundRange,
    stopSound,
    pauseSound,
    seekSound,
    getCurrentSoundTime,
    getSoundDuration,
    setSoundVolume,
    showRecordButton,
    hideRecordButton,
    showHint,
    hideHint,
    drawingAreaWidth,
    drawingAreaHeight,
    visibleAreaWidth,
    visibleAreaHeight,
    effectEvent,
    setRecognizerFeatures,
    isMouthOpen,
    isSmile,
    isEyebrowUp,
    isDisgust,
    getEyesStatus,
    getNamedState,
    isMirrored,
    getRotationVector,
    modelview
}

exports = {
    BNBApplyLightStreaks: (function() {
        const assetManager = bnb.scene.getAssetManager();

        const initAttachment = assetManager.createImage("light_streak_fullscreen_init_attachment__", bnb.ImageType.ATTACHMENT);
        const initRT = assetManager.createRenderTarget("light_streak_fullscreen_init_RT__");
        initRT.addAttachment(initAttachment);
        initRT.setScale(1 / 4);

        const fullscreenPolygon = assetManager.createStaticMesh("light_streak_fullscreen_poly__");
        assetManager.uploadMeshData(fullscreenPolygon, "$builtin$meshes/fs_tri");

        const thresholdParam = bnb.Parameter.create("light_streak_threshold");
        thresholdParam.setVector4(new bnb.Vec4(0, 0, 0, 0));

        const initMaterial = assetManager.createMaterial("init_light_streak", "$resources$/bnb_shaders/bnb/lib/init_light_streaks");
        initMaterial.addImage("s", null);
        initMaterial.addParameter(thresholdParam);
        initMaterial.setState(new bnb.State(bnb.BlendingMode.OFF, false, false, true, true));

        const initLayer = bnb.Layer.create("light_streak_fullscreen_init_layer__");
        const initEntity = bnb.scene.createEntity("light_streak_fullscreen_init_entity__");

        const initMeshInstance = bnb.MeshInstance.create();
        initMeshInstance.setVisible(true);
        initMeshInstance.setMesh(fullscreenPolygon);
        initMeshInstance.setSubGeometryMaterial("built_in_triangle", initMaterial);

        initEntity.addIntoLayer(initLayer);
        initEntity.addComponent(initMeshInstance.asComponent());

        bnb.scene.getRoot().addChild(initEntity);
        bnb.scene.getRenderList().addTask(initLayer, initRT);



        const filterAttachment0 = assetManager.createImage("light_streak_fullscreen_filter_attachment0__", bnb.ImageType.ATTACHMENT);
        const filterRT0 = assetManager.createRenderTarget("light_streak_fullscreen_filter_RT0__");
        filterRT0.addAttachment(filterAttachment0);
        filterRT0.setScale(1 / 4);

        const filterAttachment1 = assetManager.createImage("light_streak_fullscreen_filter_attachment1__", bnb.ImageType.ATTACHMENT);
        const filterRT1 = assetManager.createRenderTarget("light_streak_fullscreen_filter_RT1__");
        filterRT1.addAttachment(filterAttachment1);
        filterRT1.setScale(1 / 4);

        const filterAttachment2 = assetManager.createImage("light_streak_fullscreen_filter_attachment2__", bnb.ImageType.ATTACHMENT);
        const filterRT2 = assetManager.createRenderTarget("light_streak_fullscreen_filter_RT2__");
        filterRT2.addAttachment(filterAttachment2);
        filterRT2.setScale(1 / 4);

        const filterAttachment3 = assetManager.createImage("light_streak_fullscreen_filter_attachment3__", bnb.ImageType.ATTACHMENT);
        const filterRT3 = assetManager.createRenderTarget("light_streak_fullscreen_filter_RT3__");
        filterRT3.addAttachment(filterAttachment3);
        filterRT3.setScale(1 / 4);

        const filterMaterial0 = assetManager.createMaterial("filter_light_streaks_0", "$resources$/bnb_shaders/bnb/lib/filter_light_streaks_0");
        filterMaterial0.addImage("s", initAttachment);
        filterMaterial0.setState(new bnb.State(bnb.BlendingMode.OFF, false, false, true, true));

        const filterMaterial1 = assetManager.createMaterial("filter_light_streaks_1", "$resources$/bnb_shaders/bnb/lib/filter_light_streaks_1");
        filterMaterial1.addImage("s", filterAttachment0);
        filterMaterial1.setState(new bnb.State(bnb.BlendingMode.OFF, false, false, true, true));

        const filterMaterial2 = assetManager.createMaterial("filter_light_streaks_2", "$resources$/bnb_shaders/bnb/lib/filter_light_streaks_2");
        filterMaterial2.addImage("s", filterAttachment1);
        filterMaterial2.setState(new bnb.State(bnb.BlendingMode.OFF, false, false, true, true));

        const filterMaterial3 = assetManager.createMaterial("filter_light_streaks_3", "$resources$/bnb_shaders/bnb/lib/filter_light_streaks_3");
        filterMaterial3.addImage("s", filterAttachment2);
        filterMaterial3.setState(new bnb.State(bnb.BlendingMode.OFF, false, false, true, true));


        const filterMeshInstance0 = bnb.MeshInstance.create();
        filterMeshInstance0.setVisible(true);
        filterMeshInstance0.setMesh(fullscreenPolygon);
        filterMeshInstance0.setSubGeometryMaterial("built_in_triangle", filterMaterial0);

        const filterLayer0 = bnb.Layer.create("light_streak_fullscreen_filter_layer0__");
        const filterEntity0 = bnb.scene.createEntity("light_streak_fullscreen_filter_layer0__");
        filterEntity0.addComponent(filterMeshInstance0.asComponent());
        filterEntity0.addIntoLayer(filterLayer0);

        bnb.scene.getRoot().addChild(filterEntity0);
        bnb.scene.getRenderList().addTask(filterLayer0, filterRT0);

        const filterMeshInstance1 = bnb.MeshInstance.create();
        filterMeshInstance1.setVisible(true);
        filterMeshInstance1.setMesh(fullscreenPolygon);
        filterMeshInstance1.setSubGeometryMaterial("built_in_triangle", filterMaterial1);

        const filterLayer1 = bnb.Layer.create("light_streak_fullscreen_filter_layer1__");
        const filterEntity1 = bnb.scene.createEntity("light_streak_fullscreen_filter_layer1__");
        filterEntity1.addComponent(filterMeshInstance1.asComponent());
        filterEntity1.addIntoLayer(filterLayer1);

        bnb.scene.getRoot().addChild(filterEntity1);
        bnb.scene.getRenderList().addTask(filterLayer1, filterRT1);

        const filterMeshInstance2 = bnb.MeshInstance.create();
        filterMeshInstance2.setVisible(true);
        filterMeshInstance2.setMesh(fullscreenPolygon);
        filterMeshInstance2.setSubGeometryMaterial("built_in_triangle", filterMaterial2);

        const filterLayer2 = bnb.Layer.create("light_streak_fullscreen_filter_layer2__");
        const filterEntity2 = bnb.scene.createEntity("light_streak_fullscreen_filter_layer2__");
        filterEntity2.addComponent(filterMeshInstance2.asComponent());
        filterEntity2.addIntoLayer(filterLayer2);

        bnb.scene.getRoot().addChild(filterEntity2);
        bnb.scene.getRenderList().addTask(filterLayer2, filterRT2);

        const filterMeshInstance3 = bnb.MeshInstance.create();
        filterMeshInstance3.setVisible(true);
        filterMeshInstance3.setMesh(fullscreenPolygon);
        filterMeshInstance3.setSubGeometryMaterial("built_in_triangle", filterMaterial3);

        const filterLayer3 = bnb.Layer.create("light_streak_fullscreen_filter_layer3__");
        const filterEntity3 = bnb.scene.createEntity("light_streak_fullscreen_filter_layer3__");
        filterEntity3.addComponent(filterMeshInstance3.asComponent());
        filterEntity3.addIntoLayer(filterLayer3);

        bnb.scene.getRoot().addChild(filterEntity3);
        bnb.scene.getRenderList().addTask(filterLayer3, filterRT3);



        const applyAttachment = assetManager.createImage("light_streak_fullscreen_apply_attachment__", bnb.ImageType.ATTACHMENT);
        const applyRT = assetManager.createRenderTarget("light_streak_fullscreen_apply_RT__");
        applyRT.addAttachment(applyAttachment);

        const colorParam = bnb.Parameter.create("light_streaks_color");
        colorParam.setVector4(new bnb.Vec4(0, 0, 0, 0));

        const copyPixelsMaterial = assetManager.createMaterial("$builtin$materials/copy_pixels.100000000000", "");
        copyPixelsMaterial.addImage("tex_src", null);
        copyPixelsMaterial.setState(new bnb.State(bnb.BlendingMode.OFF, false, false, true, true));

        const applyMaterial = assetManager.createMaterial("apply_light_streak", "$resources$/bnb_shaders/bnb/lib/apply_light_streaks");
        applyMaterial.addImage("s", filterAttachment3);
        applyMaterial.addParameter(colorParam);
        applyMaterial.setState(new bnb.State(bnb.BlendingMode.OFF, false, false, true, true));


        const copyMeshInstance = bnb.MeshInstance.create();
        copyMeshInstance.setVisible(true);
        copyMeshInstance.setMesh(fullscreenPolygon);
        copyMeshInstance.setSubGeometryMaterial("built_in_triangle", copyPixelsMaterial);

        const copyLayer = bnb.Layer.create("light_streak_fullscreen_copy_layer__");
        const copyEntity = bnb.scene.createEntity("light_streak_fullscreen_copy_entity__");
        copyEntity.addComponent(copyMeshInstance.asComponent());
        copyEntity.addIntoLayer(copyLayer);

        bnb.scene.getRoot().addChild(copyEntity);
        bnb.scene.getRenderList().addTask(copyLayer, applyRT);

        const applyMeshInstance = bnb.MeshInstance.create();
        applyMeshInstance.setVisible(true);
        applyMeshInstance.setMesh(fullscreenPolygon);
        applyMeshInstance.setSubGeometryMaterial("built_in_triangle", applyMaterial);

        const applyLayer = bnb.Layer.create("light_streak_fullscreen_apply_layer__");
        const applyEntity = bnb.scene.createEntity("light_streak_fullscreen_apply_entity__");
        applyEntity.addComponent(applyMeshInstance.asComponent());
        applyEntity.addIntoLayer(applyLayer);

        bnb.scene.getRoot().addChild(applyEntity);
        bnb.scene.getRenderList().addTask(applyLayer, applyRT);

        return function(inputImage, applyImage, threshold, color, blend) {
            thresholdParam.setVector4(new bnb.Vec4(threshold, 0, 0, 1));
            initMaterial.addImage("s", inputImage);
            copyPixelsMaterial.addImage("tex_src", applyImage);
            applyMaterial.setState(new bnb.State(blend, false, false, true, true));
            colorParam.setVector4(new bnb.Vec4(color[0], color[1], color[2], color[3]));
        }
    })()
};require("./global")

/**
 * Polyfill for browser's
 * 
 * setTimeout
 * clearTimeout
 * setInterval
 * clearInterval
 */

/***/

const id = (() => {
  let id = 0
  return () => id++
})()

const eventLoop = {
  /**
   * @param {Function} listener
   * @returns {Function} unsubscribe
   */
  subscribe: (listener) => {
    bnb.eventListener.on("onUpdate", listener)

    return () => {
      bnb.eventListener.off("onUpdate", listener)
    }
  }
}

/** @type {Map<number, Function>} */
const timers = new Map()

/**
 * @param {Function} callback - A function to be executyed every `delay` milliseconds.
 * @param {number} [delay] - The time, in milliseconds (thousandths of a second), the timer should delay in between executions of the specified function.
 * @param {...*} args - Additional arguments which are passed through to the function specified by func once the timer expires.
 * @returns {number} intervalID - The returned intervalID is a numeric, non-zero value which identifies the timer created by the call to setInterval();
 * this value can be passed to {@link clearInterval} to cancel the interval.
 * 
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval
 */
const setInterval = (callback, delay = 0, ...args) => {
  let start = Date.now()

  const intervalId = id()
  const unsubscribe = eventLoop.subscribe(() => {
    if (Date.now() - start < delay) return

    start = Date.now()

    callback(...args)
  })

  timers.set(intervalId, unsubscribe)

  return intervalId
}

/**
 * @param {number} intervalID - The identifier of the repeated action you want to cancel.
 * This ID was returned by the corresponding call to {@link setInterval}.
 */
const clearInterval = (intervalID) => {
  const unsubscribe = timers.get(intervalID)

  if (unsubscribe) unsubscribe()

  timers.delete(intervalID)
}

/**
 * @param {Function} callback - A function to be executyed after the timer expires.
 * @param {number} [delay] - The time, in milliseconds that the timer should wait before the specified function or code is executed.
 * If this parameter is omitted, a value of 0 is used, meaning execute "immediately", or more accurately, the next event cycle.
 * @param {...*} args - Additional arguments which are passed through to the function specified by func once the timer expires.
 * @returns {number} timeoutID - The returned timeoutID is a positive integer value which identifies the timer created by the call to setTimeout().
 * This value can be passed to {@link clearTimeout} to cancel the timeout.
 * 
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout
 */
const setTimeout = (callback, delay = 0, ...args) => {
  const timeoutID = setInterval(() => {
    clearInterval(timeoutID)

    callback(...args)
  }, delay)

  return timeoutID
}

/**
 * @param {number} timeoutID - The identifier of the timeout you want to cancel.
 * This ID was returned by the corresponding call to {@link setTimeout}.
 */
const clearTimeout = clearInterval

if (!globalThis.setInterval && !globalThis.clearInterval) {
  globalThis.setInterval = setInterval
  globalThis.clearInterval = clearInterval
}

if (!globalThis.setTimeout && !globalThis.clearTimeout) {
  globalThis.setTimeout = setTimeout
  globalThis.clearTimeout = clearTimeout
}For future versions#ifndef BNB_ANIM_TRANSFORM_GLSL
#define BNB_ANIM_TRANSFORM_GLSL

#include <bnb/get_bone.glsl>
#include <bnb/get_transform.glsl>

#endif // BNB_ANIM_TRANSFORM_GLSL
// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl
// https://github.com/graypegg/chromatism

#ifndef BNB_COLOR_SPACES_GLSL
#define BNB_COLOR_SPACES_GLSL

// D65
const vec3 bnb_color_spaces_WHITE = vec3(0.95047, 1.0000, 1.08883);
const float bnb_color_spaces_EPSILON = 216. / 24389.;
const float bnb_color_spaces_KAPPA = 24389. / 27.;
const float bnb_color_spaces_PI = 3.1415926538;

// clang-format off
const mat3 bnb_color_spaces_RGB_TO_XYZ = mat3(
    0.4124564, 0.2126729, 0.0193339, 
    0.3575761, 0.7151522, 0.1191920, 
    0.1804375, 0.0721750, 0.9503041
);

const mat3 bnb_color_spaces_XYZ_TO_RGB = mat3(
    3.2404542, -0.9692660, 0.0556434, 
    -1.5371385, 1.8760108, -0.2040259, 
    -0.4985314, 0.0415560, 1.0572252
);
// clang-format on

const float bnb_color_spaces_YUV2RGB_RED_CrV = 1.402;
const float bnb_color_spaces_YUV2RGB_GREEN_CbU = 0.3441;
const float bnb_color_spaces_YUV2RGB_GREEN_CrV = 0.7141;
const float bnb_color_spaces_YUV2RGB_BLUE_CbU = 1.772;

vec3 bnb_sRGB_to_linear(vec3 srgb)
{
    return vec3(
        srgb.r <= 0.04045 ? srgb.r / 12.92 : pow((srgb.r + 0.055) / 1.055, 2.4),
        srgb.g <= 0.04045 ? srgb.g / 12.92 : pow((srgb.g + 0.055) / 1.055, 2.4),
        srgb.b <= 0.04045 ? srgb.b / 12.92 : pow((srgb.b + 0.055) / 1.055, 2.4)
    );
}

vec3 bnb_linear_to_sRGB(vec3 lrgb)
{
    return vec3(
        lrgb.r <= 0.0031308 ? lrgb.r * 12.92 : 1.055 * pow(lrgb.r, 1.0 / 2.4) - 0.055,
        lrgb.g <= 0.0031308 ? lrgb.g * 12.92 : 1.055 * pow(lrgb.g, 1.0 / 2.4) - 0.055,
        lrgb.b <= 0.0031308 ? lrgb.b * 12.92 : 1.055 * pow(lrgb.b, 1.0 / 2.4) - 0.055
    );
}


/* yuva */


vec4 bnb_rgba_to_yuva(vec4 rgba)
{
    vec4 yuva = vec4(0.);

    yuva.x = rgba.r * 0.299 + rgba.g * 0.587 + rgba.b * 0.114;
    yuva.y = rgba.r * -0.169 + rgba.g * -0.331 + rgba.b * 0.5 + 0.5;
    yuva.z = rgba.r * 0.5 + rgba.g * -0.419 + rgba.b * -0.081 + 0.5;
    yuva.w = rgba.a;

    return yuva;
}

vec4 bnb_yuva_to_rgba(vec4 yuva)
{
    float y = yuva.x;
    float u = yuva.y - 0.5;
    float v = yuva.z - 0.5;

    float r = y + bnb_color_spaces_YUV2RGB_RED_CrV * v;
    float g = y - bnb_color_spaces_YUV2RGB_GREEN_CbU * u - bnb_color_spaces_YUV2RGB_GREEN_CrV * v;
    float b = y + bnb_color_spaces_YUV2RGB_BLUE_CbU * u;

    return vec4(r, g, b, yuva.a);
}


/* XYZ */


vec3 bnb_rgb_to_XYZ(vec3 rgb)
{
    return bnb_color_spaces_RGB_TO_XYZ * rgb;
}

vec3 bnb_XYZ_to_rgb(vec3 xyz)
{
    return clamp(bnb_color_spaces_XYZ_TO_RGB * xyz, 0., 1.);
}


/* Luv */

// https://www.easyrgb.com/en/math.php
// http://www.brucelindbloom.com/index.html?Math.html

vec2 bnb_color_spaces_chrome_coords(vec3 c)
{
    return c.xy * vec2(4., 9.) / (c.x + 15. * c.y + 3. * c.z);
}

vec3 bnb_XYZ_to_Luv(vec3 xyz)
{
    float yr = xyz.y / bnb_color_spaces_WHITE.y;

    float L = yr > bnb_color_spaces_EPSILON
                  ? (116. * pow(yr, 1. / 3.)) - 16.
                  : bnb_color_spaces_KAPPA * yr;

    vec2 uv_ = bnb_color_spaces_chrome_coords(xyz);
    vec2 uv_r = bnb_color_spaces_chrome_coords(bnb_color_spaces_WHITE);

    vec2 uv = 13. * L * (uv_ - uv_r);

    return vec3(L, uv);
}

vec3 bnb_Luv_to_XYZ(vec3 luv)
{
    vec2 uv0 = bnb_color_spaces_chrome_coords(bnb_color_spaces_WHITE);

    float a = (1. / 3.) * (52. * luv.x / (luv.y + 13. * luv.x * uv0.x) - 1.);

    float Y = luv.x > (bnb_color_spaces_KAPPA * bnb_color_spaces_EPSILON)
                  ? (pow(((luv.x + 16.) / 116.), 3.))
                  : luv.x / bnb_color_spaces_KAPPA;

    float b = -5. * Y;
    float d = Y * (((39. * luv.x) / (luv.z + ((13. * luv.x) * uv0.y))) - 5.);

    float X = (d - b) / (a - (-1. / 3.));
    float Z = (X * a) + b;

    return vec3(X, Y, Z);
}


/* LCh */


vec3 bnb_Luv_to_LCh(vec3 luv)
{
    float L = luv.x;
    float C = sqrt(pow(luv.y / 100., 2.) + pow(luv.z / 100., 2.));

    float h = atan(luv.z, luv.y);

    if (h < 0.)
        h += (2. * bnb_color_spaces_PI);

    h = degrees(h);

    return vec3(L / 100., C, h);
}

vec3 bnb_LCh_to_Luv(vec3 lch)
{
    float L = lch.x;

    float h = radians(lch.z);

    float u = lch.y * cos(h);
    float v = lch.y * sin(h);

    return vec3(L * 100., u * 100., v * 100.);
}


/* YIQ / YUV */


vec3 bnb_rgb_to_YIQ(vec3 rgb)
{
    float y = (0.299 * rgb.r) + (0.587 * rgb.g) + (0.114 * rgb.b);
    float i = (0.596 * rgb.r) + (-0.274 * rgb.g) + (-0.322 * rgb.b);
    float q = (0.211 * rgb.r) + (-0.523 * rgb.g) + (0.312 * rgb.b);
    /* YIQ is not a transformation of RGB, so it's pretty lossy */
    i = clamp(i, -0.5957, 0.5957);
    q = clamp(q, -0.5226, 0.5226);

    return vec3(y, i, q);
}

vec3 bnb_YIQ_to_rgb(vec3 yiq)
{
    float i = clamp(yiq.y, -0.5957, 0.5957);
    float q = clamp(yiq.z, -0.5226, 0.5226);

    float r = clamp(yiq.x + (0.956 * i) + (0.621 * q), 0., 1.);
    float g = clamp(yiq.x + (-0.272 * i) + (-0.647 * q), 0., 1.);
    float b = clamp(yiq.x + (-1.106 * i) + (-1.703 * q), 0., 1.);

    return vec3(r, g, b);
}


/* Helpers */

// Those functions should not be used in new effects as there is no search for
// closest representable RGB color in conversion from XYZ.
// There is just a clamp into [0,1] RGB in bnb_XYZ_to_rgb
// and this can produce wrong colors in some edge cases.

// skip sRGB <-> linear conversions in LCh helpers
// to make Makeup effect from v1.7 work the same way with later sdk versions

vec3 bnb_rgb_to_LCh(vec3 rgb)
{
    return bnb_Luv_to_LCh(bnb_XYZ_to_Luv(bnb_rgb_to_XYZ(/*bnb_sRGB_to_linear*/ (rgb))));
}

vec3 bnb_LCh_to_rgb(vec3 lch)
{
    return /*bnb_linear_to_sRGB*/ (bnb_XYZ_to_rgb(bnb_Luv_to_XYZ(bnb_LCh_to_Luv(lch))));
}

vec3 bnb_rgb_to_Luv(vec3 rgb)
{
    return bnb_XYZ_to_Luv(bnb_rgb_to_XYZ(bnb_sRGB_to_linear(rgb)));
}

vec3 bnb_Luv_to_rgb(vec3 luv)
{
    return bnb_linear_to_sRGB(bnb_XYZ_to_rgb(bnb_Luv_to_XYZ(luv)));
}

#endif // BNB_COLOR_SPACES_GLSL
#ifndef BNB_DECODE_INT1010102_GLSL
#define BNB_DECODE_INT1010102_GLSL

#if defined(BNB_VK_1)
vec4 bnb_decode_int1010102(uint u)
{
    float ux = u & 1023u;
    float uy = (u >> 10u) & 1023u;
    float uz = (u >> 20u) & 1023u;
    float uw = u >> 30u;
    float x = float(ux <= 511u ? ux : ux - 1024u) / 511.;
    float y = float(uy <= 511u ? uy : uy - 1024u) / 511.;
    float z = float(uz <= 511u ? uz : uz - 1024u) / 511.;
    float w = float(uw <= 1u ? uw : uw - 4u);
    return vec4(x, y, z, w);
}
#else
    #define bnb_decode_int1010102(v) v
#endif

/** decode_int1010102 is DEPRECATED */
#define decode_int1010102(arg) bnb_decode_int1010102(arg)

#endif // BNB_DECODE_INT1010102_GLSL#ifndef BNB_GET_BONE_GLSL
#define BNB_GET_BONE_GLSL

mat4 bnb_get_bone(uint bone_idx, int y)
{
    int b = int(bone_idx) * 3;
    mat4 m = mat4(
        texelFetch(BNB_SAMPLER_2D(bnb_BONES), ivec2(b, y), 0),
        texelFetch(BNB_SAMPLER_2D(bnb_BONES), ivec2(b + 1, y), 0),
        texelFetch(BNB_SAMPLER_2D(bnb_BONES), ivec2(b + 2, y), 0),
        vec4(0., 0., 0., 1.)
    );
    return m;
}

#endif // BNB_GET_BONE_GLSL
#ifndef BNB_GET_TRANSFORN_GLSL
#define BNB_GET_TRANSFORN_GLSL

mat4 bnb_get_transform()
{
    int y = int(bnb_ANIMKEY);
    mat4 m = bnb_get_bone(attrib_bones[0], y);
#ifndef BNB_1_BONE
    if (attrib_weights[1] > 0.) {
        m = m * attrib_weights[0] + bnb_get_bone(attrib_bones[1], y) * attrib_weights[1];

        if (attrib_weights[2] > 0.) {
            m += bnb_get_bone(attrib_bones[2], y) * attrib_weights[2];

            if (attrib_weights[3] > 0.) {
                m += bnb_get_bone(attrib_bones[3], y) * attrib_weights[3];
            }
        }
    }
#endif // BNB_1_BONE
    return m;
}

#endif // BNB_GET_TRANSFORN_GLSL/**
 * Common frgament sgader declaration. Always make it as first include.
 * Other includes rely on it.
 */


#ifndef BNB_FRAGMENT_SHADER
#define BNB_FRAGMENT_SHADER

#include <bnb/version.glsl>

#include <bnb/samplers_declaration.glsl>
#include <bnb/textures_lookup.glsl>

//---------- In-out ----------

#if defined(BNB_GL_ES_3) || defined(BNB_GL)
    #define BNB_IN(l) in
#else
    #define BNB_IN(l) layout(location = l) in
#endif

#define BNB_CENTROID centroid
// declare out color
layout(location = 0) out vec4 bnb_FragColor;
#endif // BNB_FRAGMENT_SHADER/**
 * Common vertex shader declaration. Always include first. Always
 * include in `main` source only.
 * Other includes rely on it.
 */

#ifndef BNB_VERTEX_SHADER
#define BNB_VERTEX_SHADER

#include <bnb/version.glsl>
#include <bnb/samplers_declaration.glsl>
#include <bnb/textures_lookup.glsl>

#define BNB_IN in

#if defined(BNB_GL_ES_3) || defined(BNB_GL)
    #define BNB_OUT(l) out
    #define BNB_LAYOUT_LOCATION(l) layout(location = l)
#elif defined(BNB_VK_1)
    #define BNB_OUT(l) layout(location = l) out
    #define BNB_LAYOUT_LOCATION(l) layout(location = l)
out gl_PerVertex
{
    vec4 gl_Position;
    float gl_PointSize;
};
#endif

#ifdef BNB_VK_1
    #define gl_VertexID gl_VertexIndex
    #define gl_InstanceID gl_InstanceIndex
#endif

#endif // BNB_VERTEX_SHADER#include <bnb/glsl.frag>

BNB_DECLARE_SAMPLER_2D(0, 1, s);
BNB_IN(0)
vec2 var_uv;

void main()
{
    float streak = dot(textureLod(BNB_SAMPLER_2D(s), var_uv, 0.), vec4(1.));
    if (streak < 1. / 255.)
        discard;
    vec3 color = light_streaks_color.rgb;
    bnb_FragColor = vec4(color * streak, streak);
}#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_pos;

BNB_OUT(0)
vec2 var_uv;

void main()
{
    vec2 v = attrib_pos;
    gl_Position = vec4(v, 0., 1.);
    var_uv = v * 0.5 + 0.5;
#ifdef BNB_VK_1
    var_uv.y = 1. - var_uv.y;
#endif
}#include <bnb/glsl.frag>

BNB_IN(0)
vec3 translation;

void main()
{
    bnb_FragColor = vec4(translation, 1.);
}#include <bnb/glsl.vert>

layout(location = 0) in vec3 attrib_pos;
layout(location = 1) in vec3 attrib_static_pos;
layout(location = 2) in vec2 attrib_uv;
layout(location = 3) in vec4 attrib_mask;

BNB_OUT(0)
vec3 translation;

vec2 glfx_morph_coord(vec3 v)
{
    const float half_angle = radians(104.);
    const float y0 = -110.;
    const float y1 = 112.;
    float x = atan(v.x, v.z) / half_angle;
    float y = ((v.y - y0) / (y1 - y0)) * 2. - 1.;
    return vec2(x, y);
}

void main()
{
    gl_Position = vec4(glfx_morph_coord(attrib_static_pos), 0., 1.);
    translation = attrib_pos - attrib_static_pos;
}#include <bnb/glsl.frag>

BNB_IN(0)
vec3 translation;

void main()
{
    bnb_FragColor = vec4(translation, 1.);
}#include <bnb/glsl.vert>

layout(location = 0) in vec3 attrib_pos;
layout(location = 1) in vec3 attrib_static_pos;
layout(location = 2) in vec2 attrib_uv;
layout(location = 3) in vec4 attrib_mask;

BNB_OUT(0)
vec3 translation;

void main()
{
    vec2 v = smoothstep(0., 1., attrib_uv) * 2. - 1.;
    gl_Position = vec4(v, 0., 1.);
    const float max_range = 40.; // morph translation will be clamped to [-max_range,+max_range]
    translation = ((attrib_pos - attrib_static_pos) / max_range) * 0.5 + 0.5;
}#include <bnb/glsl.frag>

centroid BNB_IN(0) vec2 var_c;

void main()
{
    bnb_FragColor = vec4(var_c, 0., 0.);
}#include <bnb/glsl.vert>

layout(location = 0) in vec3 attrib_original;
layout(location = 1) in vec3 attrib_morph;

centroid BNB_OUT(0) vec2 var_c;

void main()
{
    const int EXPAND_PASSES = 8;
    const float NPUSH = 75.;

    int i = int(gl_InstanceID);

    float scale = 1. - float(i) / float(EXPAND_PASSES + 1);
    scale = scale * scale * (3. - 2. * scale); // smoothstep fall-off
    float d0 = float(i) / float(EXPAND_PASSES + 1);
    float d1 = float(i + 1) / float(EXPAND_PASSES + 1);

#ifndef BNB_VK_1
    vec4 npush_scale = vec4(NPUSH * float(i) / float(EXPAND_PASSES), scale * 0.5, d1 - d0, d0 + d1 - 1.);
#else
    vec4 npush_scale = vec4(NPUSH * float(i) / float(EXPAND_PASSES), scale * 0.5, (d1 - d0) * 0.5, (d0 + d1) * 0.5);
#endif

    gl_Position = bnb_MVP * vec4(attrib_morph * (1. + npush_scale.x / length(attrib_morph)), 1.);
    gl_Position.z = gl_Position.z * npush_scale.z + gl_Position.w * npush_scale.w;
    vec4 pos_no_push = bnb_MVP * vec4(attrib_morph, 1.);
    vec4 original_pos = bnb_MVP * vec4(attrib_original, 1.);
    var_c = npush_scale.y * (original_pos.xy / original_pos.w - pos_no_push.xy / pos_no_push.w);
}#include <bnb/glsl.frag>

BNB_DECLARE_SAMPLER_2D(0, 1, s_downscale_tex);

BNB_IN(0)
vec2 var_uv;

void main()
{
    vec4 pixel = textureLod(BNB_SAMPLER_2D(s_downscale_tex), var_uv, 0.);

    vec4 pp = textureLodOffset(BNB_SAMPLER_2D(s_downscale_tex), var_uv, 0., ivec2(1, 1));
    vec4 mp = textureLodOffset(BNB_SAMPLER_2D(s_downscale_tex), var_uv, 0., ivec2(-1, 1));
    vec4 mm = textureLodOffset(BNB_SAMPLER_2D(s_downscale_tex), var_uv, 0., ivec2(-1, -1));
    vec4 pm = textureLodOffset(BNB_SAMPLER_2D(s_downscale_tex), var_uv, 0., ivec2(1, -1));

    // clang-format off
    vec3 sum = (0.5*pixel.xyz*(1. - pixel.w) + 0.125*(pp.xyz*(1. - pp.w) + mp.xyz*(1. - mp.w) + mm.xyz*(1. - mm.w) + pm.xyz*(1. - pm.w)))
        / (0.5*(1. - pixel.w) + 0.125*((1. - pp.w) + (1. - mp.w) + (1. - mm.w) + (1. - pm.w)));
    // clang-format on
    bnb_FragColor = vec4(sum, pixel.w);
}#include <bnb/glsl.vert>

layout(location = 0) in vec3 attrib_pos;

BNB_OUT(0)
vec2 var_uv;

void main()
{
    vec2 v = attrib_pos.xy;
    gl_Position = vec4(v, 0., 1.);
    var_uv = v * 0.5 + 0.5;
}#include <bnb/glsl.frag>

BNB_DECLARE_SAMPLER_2D(0, 1, s_upscale_tex);

BNB_IN(0)
vec4 var_uv;

void main()
{
    // clang-format off
    vec3 sum =
        (1. / 6.) * (
            textureLod(BNB_SAMPLER_2D(s_upscale_tex), var_uv.zw, 0.).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.zw, 0., ivec2(-1, 0)).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.zw, 0., ivec2(0, -1)).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.zw, 0., ivec2(-1, -1)).xyz) +
        (1. / 12.) * (
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.xy, 0., ivec2(1, 0)).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.xy, 0., ivec2(-1, 0)).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.xy, 0., ivec2(0, 1)).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.xy, 0., ivec2(0, -1)).xyz);
    // clang-format on

    bnb_FragColor = vec4(sum, 1.);
}
#include <bnb/glsl.vert>

layout(location = 0) in vec3 attrib_pos;

BNB_DECLARE_SAMPLER_2D(0, 1, s_upscale_tex);

BNB_OUT(0)
vec4 var_uv;

void main()
{
    vec2 v = attrib_pos.xy;
    gl_Position = vec4(v, 0., 1.);
    var_uv.xy = v * 0.5 + 0.5;
    var_uv.zw = var_uv.xy + 0.5 / vec2(textureSize(BNB_SAMPLER_2D(s_upscale_tex), 0));
}#include <bnb/glsl.frag>

BNB_DECLARE_SAMPLER_2D(0, 1, s_upscale_tex);
BNB_DECLARE_SAMPLER_2D(2, 3, s_src_tex);

BNB_IN(0)
vec4 var_uv;

void main()
{
    // clang-format off
    vec3 sum =
        (1. / 6.) * (
            textureLod(BNB_SAMPLER_2D(s_upscale_tex), var_uv.zw, 0.).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.zw, 0., ivec2(-1, 0)).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.zw, 0., ivec2(0, -1)).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.zw, 0., ivec2(-1, -1)).xyz) +
        (1. / 12.) * (
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.xy, 0., ivec2(1, 0)).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.xy, 0., ivec2(-1, 0)).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.xy, 0., ivec2(0, 1)).xyz +
            textureLodOffset(BNB_SAMPLER_2D(s_upscale_tex), var_uv.xy, 0., ivec2(0, -1)).xyz);
    // clang-format on
    vec2 src_uv = var_uv.xy;
#ifdef BNB_VK_1
    src_uv.y = 1. - src_uv.y;
#endif
    vec4 src = textureLod(BNB_SAMPLER_2D(s_src_tex), src_uv, 0.);

    bnb_FragColor = vec4(mix(sum, src.xyz, src.w), 1.);
}
#include <bnb/glsl.frag>

BNB_IN(0)
vec2 var_uv;

BNB_DECLARE_SAMPLER_2D(0, 1, tex_y);
BNB_DECLARE_SAMPLER_2D(2, 3, tex_u);
BNB_DECLARE_SAMPLER_2D(4, 5, tex_v);
BNB_DECLARE_SAMPLER_2D(6, 7, tex_uv);
BNB_DECLARE_SAMPLER_2D(8, 9, tex_rgb);

#include <bnb/sample_camera.glsl>

void main()
{
    vec2 uv = var_uv;
    bnb_FragColor = bnb_sample_camera(uv);
    // discard pixels where uv values are out of range [0, 1]
    vec2 s = step(vec2(0., 0.), uv) - step(vec2(1., 1.), uv);
    bnb_FragColor.rgb = mix(vec3(0., 0., 0.), bnb_FragColor.rgb, s.x * s.y);
    bnb_FragColor.a = 1.;
}#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_pos;

BNB_OUT(0)
vec2 var_uv;

void main()
{
    vec2 v = attrib_pos;
    gl_Position = vec4(v, 0., 1.);

    mat2 ori = mat2(bnb_camera_orientation.xy, bnb_camera_orientation.zw);
    var_uv = (ori * vec2(v.x * bnb_camera_scale_i420.x, v.y)) * 0.5 + 0.5;
}#include <bnb/glsl.frag>

BNB_IN(0)
vec4 var_uv;

BNB_DECLARE_SAMPLER_2D(0, 1, tex_y);
BNB_DECLARE_SAMPLER_2D(2, 3, tex_u);
BNB_DECLARE_SAMPLER_2D(4, 5, tex_v);
BNB_DECLARE_SAMPLER_2D(6, 7, tex_uv);
BNB_DECLARE_SAMPLER_2D(8, 9, tex_rgb);
BNB_DECLARE_SAMPLER_2D(10, 11, tex_bg_mask);

#include <bnb/sample_camera.glsl>

void main()
{
    vec2 uv = var_uv.xy;
    bnb_FragColor = bnb_sample_camera(uv);
    // discard pixels where uv values are out of range [0, 1]
    vec2 s = step(vec2(0., 0.), uv) - step(vec2(1., 1.), uv);
    bnb_FragColor.rgb = mix(vec3(0., 0., 0.), bnb_FragColor.rgb, s.x * s.y);
    float bg_mask_multiplier = bnb_rgba_camera.y;
    bnb_FragColor.a = 1. - textureLod(BNB_SAMPLER_2D(tex_bg_mask), var_uv.zw, 0.).x * bg_mask_multiplier;
}#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_pos;

BNB_OUT(0)
vec4 var_uv;

void main()
{
    vec2 v = attrib_pos;
    gl_Position = vec4(v, 0., 1.);

    mat2 ori = mat2(bnb_camera_orientation.xy, bnb_camera_orientation.zw);
    var_uv.xy = (ori * vec2(v.x * bnb_camera_scale_i420.x, v.y)) * 0.5 + 0.5;
    var_uv.zw = vec2(vec3(v, 1.) * mat3(background_nn_transform));
}#include <bnb/glsl.frag>

BNB_IN(0)
vec2 var_uv;

BNB_DECLARE_SAMPLER_2D(0, 1, tex_src);

void main()
{
    bnb_FragColor = textureLod(BNB_SAMPLER_2D(tex_src), var_uv, 0.);
}#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_pos;

BNB_OUT(0)
vec2 var_uv;

void main()
{
    vec2 v = attrib_pos;
    gl_Position = vec4(v, 0., 1.);
    var_uv = v * 0.5 + 0.5;
#ifdef BNB_VK_1
    var_uv.y = 1. - var_uv.y;
#endif
}#include <bnb/glsl.frag>

BNB_IN(0)
vec4 var_uv_off;

BNB_DECLARE_SAMPLER_2D(0, 1, s);

void main()
{
    vec2 uv = var_uv_off.xy;
    vec2 d = var_uv_off.zw;

    float s0 = 2. * 0.20236;
    float s1 = 0.124009 + 0.179044;
    float s2 = 0.028532 + 0.067234;

    float o1 = 1. + 0.179044 / s1;
    float o2 = 3. + 0.067234 / s2;

    vec4 c = s0 * textureLod(BNB_SAMPLER_2D(s), uv, 0.);

    vec2 uv_off = d * o1;
    c += s1 * vec4(textureLod(BNB_SAMPLER_2D(s), uv + uv_off, 0.).x, textureLod(BNB_SAMPLER_2D(s), uv + vec2(uv_off.x, -uv_off.y), 0.).y, textureLod(BNB_SAMPLER_2D(s), uv - uv_off, 0.).z, textureLod(BNB_SAMPLER_2D(s), uv + vec2(-uv_off.x, uv_off.y), 0.).w);

    uv_off = d * o2;
    c += s2 * vec4(textureLod(BNB_SAMPLER_2D(s), uv + uv_off, 0.).x, textureLod(BNB_SAMPLER_2D(s), uv + vec2(uv_off.x, -uv_off.y), 0.).y, textureLod(BNB_SAMPLER_2D(s), uv - uv_off, 0.).z, textureLod(BNB_SAMPLER_2D(s), uv + vec2(-uv_off.x, uv_off.y), 0.).w);

    bnb_FragColor = c * 1.3;
}#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_pos;

#define PASS_ID 0

BNB_DECLARE_SAMPLER_2D(0, 1, s);

BNB_OUT(0)
vec4 var_uv_off;

void main()
{
    vec2 v = attrib_pos;
    gl_Position = vec4(v, 0., 1.);
    vec2 uv = v * 0.5 + 0.5;

    vec2 px_size = 1. / vec2(bnb_SCREEN.xy / 4.0);
    float kernel_scales[4];
    kernel_scales[0] = 1.;
    kernel_scales[1] = 1.3;
    kernel_scales[2] = 1.3 * 1.3;
    kernel_scales[3] = 1.3 * 1.3 * 1.3;
    var_uv_off = vec4(uv, px_size * kernel_scales[PASS_ID]);
#ifdef BNB_VK_1
    var_uv_off.y = 1. - var_uv_off.y;
#endif
}#include <bnb/glsl.frag>

BNB_IN(0)
vec4 var_uv_off;

BNB_DECLARE_SAMPLER_2D(0, 1, s);

void main()
{
    vec2 uv = var_uv_off.xy;
    vec2 d = var_uv_off.zw;

    float s0 = 2. * 0.20236;
    float s1 = 0.124009 + 0.179044;
    float s2 = 0.028532 + 0.067234;

    float o1 = 1. + 0.179044 / s1;
    float o2 = 3. + 0.067234 / s2;

    vec4 c = s0 * textureLod(BNB_SAMPLER_2D(s), uv, 0.);

    vec2 uv_off = d * o1;
    c += s1 * vec4(textureLod(BNB_SAMPLER_2D(s), uv + uv_off, 0.).x, textureLod(BNB_SAMPLER_2D(s), uv + vec2(uv_off.x, -uv_off.y), 0.).y, textureLod(BNB_SAMPLER_2D(s), uv - uv_off, 0.).z, textureLod(BNB_SAMPLER_2D(s), uv + vec2(-uv_off.x, uv_off.y), 0.).w);

    uv_off = d * o2;
    c += s2 * vec4(textureLod(BNB_SAMPLER_2D(s), uv + uv_off, 0.).x, textureLod(BNB_SAMPLER_2D(s), uv + vec2(uv_off.x, -uv_off.y), 0.).y, textureLod(BNB_SAMPLER_2D(s), uv - uv_off, 0.).z, textureLod(BNB_SAMPLER_2D(s), uv + vec2(-uv_off.x, uv_off.y), 0.).w);

    bnb_FragColor = c * 1.3;
}#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_pos;

#define PASS_ID 1

BNB_DECLARE_SAMPLER_2D(0, 1, s);

BNB_OUT(0)
vec4 var_uv_off;

void main()
{
    vec2 v = attrib_pos;
    gl_Position = vec4(v, 0., 1.);
    vec2 uv = v * 0.5 + 0.5;

    vec2 px_size = 1. / vec2(bnb_SCREEN.xy / 4.0);
    float kernel_scales[4];
    kernel_scales[0] = 1.;
    kernel_scales[1] = 1.3;
    kernel_scales[2] = 1.3 * 1.3;
    kernel_scales[3] = 1.3 * 1.3 * 1.3;
    var_uv_off = vec4(uv, px_size * kernel_scales[PASS_ID]);
#ifdef BNB_VK_1
    var_uv_off.y = 1. - var_uv_off.y;
#endif
}#include <bnb/glsl.frag>

BNB_IN(0)
vec4 var_uv_off;

BNB_DECLARE_SAMPLER_2D(0, 1, s);

void main()
{
    vec2 uv = var_uv_off.xy;
    vec2 d = var_uv_off.zw;

    float s0 = 2. * 0.20236;
    float s1 = 0.124009 + 0.179044;
    float s2 = 0.028532 + 0.067234;

    float o1 = 1. + 0.179044 / s1;
    float o2 = 3. + 0.067234 / s2;

    vec4 c = s0 * textureLod(BNB_SAMPLER_2D(s), uv, 0.);

    vec2 uv_off = d * o1;
    c += s1 * vec4(textureLod(BNB_SAMPLER_2D(s), uv + uv_off, 0.).x, textureLod(BNB_SAMPLER_2D(s), uv + vec2(uv_off.x, -uv_off.y), 0.).y, textureLod(BNB_SAMPLER_2D(s), uv - uv_off, 0.).z, textureLod(BNB_SAMPLER_2D(s), uv + vec2(-uv_off.x, uv_off.y), 0.).w);

    uv_off = d * o2;
    c += s2 * vec4(textureLod(BNB_SAMPLER_2D(s), uv + uv_off, 0.).x, textureLod(BNB_SAMPLER_2D(s), uv + vec2(uv_off.x, -uv_off.y), 0.).y, textureLod(BNB_SAMPLER_2D(s), uv - uv_off, 0.).z, textureLod(BNB_SAMPLER_2D(s), uv + vec2(-uv_off.x, uv_off.y), 0.).w);

    bnb_FragColor = c * 1.3;
}#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_pos;

#define PASS_ID 2

BNB_DECLARE_SAMPLER_2D(0, 1, s);

BNB_OUT(0)
vec4 var_uv_off;

void main()
{
    vec2 v = attrib_pos;
    gl_Position = vec4(v, 0., 1.);
    vec2 uv = v * 0.5 + 0.5;

    vec2 px_size = 1. / vec2(bnb_SCREEN.xy / 4.0);
    float kernel_scales[4];
    kernel_scales[0] = 1.;
    kernel_scales[1] = 1.3;
    kernel_scales[2] = 1.3 * 1.3;
    kernel_scales[3] = 1.3 * 1.3 * 1.3;
    var_uv_off = vec4(uv, px_size * kernel_scales[PASS_ID]);
#ifdef BNB_VK_1
    var_uv_off.y = 1. - var_uv_off.y;
#endif
}#include <bnb/glsl.frag>

BNB_IN(0)
vec4 var_uv_off;

BNB_DECLARE_SAMPLER_2D(0, 1, s);

void main()
{
    vec2 uv = var_uv_off.xy;
    vec2 d = var_uv_off.zw;

    float s0 = 2. * 0.20236;
    float s1 = 0.124009 + 0.179044;
    float s2 = 0.028532 + 0.067234;

    float o1 = 1. + 0.179044 / s1;
    float o2 = 3. + 0.067234 / s2;

    vec4 c = s0 * textureLod(BNB_SAMPLER_2D(s), uv, 0.);

    vec2 uv_off = d * o1;
    c += s1 * vec4(textureLod(BNB_SAMPLER_2D(s), uv + uv_off, 0.).x, textureLod(BNB_SAMPLER_2D(s), uv + vec2(uv_off.x, -uv_off.y), 0.).y, textureLod(BNB_SAMPLER_2D(s), uv - uv_off, 0.).z, textureLod(BNB_SAMPLER_2D(s), uv + vec2(-uv_off.x, uv_off.y), 0.).w);

    uv_off = d * o2;
    c += s2 * vec4(textureLod(BNB_SAMPLER_2D(s), uv + uv_off, 0.).x, textureLod(BNB_SAMPLER_2D(s), uv + vec2(uv_off.x, -uv_off.y), 0.).y, textureLod(BNB_SAMPLER_2D(s), uv - uv_off, 0.).z, textureLod(BNB_SAMPLER_2D(s), uv + vec2(-uv_off.x, uv_off.y), 0.).w);

    bnb_FragColor = c * 1.3;
}#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_pos;

#define PASS_ID 3

BNB_DECLARE_SAMPLER_2D(0, 1, s);

BNB_OUT(0)
vec4 var_uv_off;

void main()
{
    vec2 v = attrib_pos;
    gl_Position = vec4(v, 0., 1.);
    vec2 uv = v * 0.5 + 0.5;

    vec2 px_size = 1. / vec2(bnb_SCREEN.xy / 4.0);
    float kernel_scales[4];
    kernel_scales[0] = 1.;
    kernel_scales[1] = 1.3;
    kernel_scales[2] = 1.3 * 1.3;
    kernel_scales[3] = 1.3 * 1.3 * 1.3;
    var_uv_off = vec4(uv, px_size * kernel_scales[PASS_ID]);
#ifdef BNB_VK_1
    var_uv_off.y = 1. - var_uv_off.y;
#endif
}#include <bnb/glsl.frag>

precision mediump float;
precision mediump sampler2DArray;
precision mediump sampler2DShadow;

BNB_IN(0)
vec2 var_uv;
BNB_IN(1)
vec3 var_t;
BNB_IN(2)
vec3 var_b;
BNB_IN(3)
vec3 var_n;
BNB_IN(4)
vec3 var_v;

BNB_DECLARE_SAMPLER_2D(0, 1, base_color);
BNB_DECLARE_SAMPLER_2D(2, 3, metallic_roughness);
BNB_DECLARE_SAMPLER_2D(4, 5, normal);
BNB_DECLARE_SAMPLER_CUBE(6, 7, tex_ibl_diff);
BNB_DECLARE_SAMPLER_CUBE(8, 9, tex_ibl_spec);
BNB_DECLARE_SAMPLER_2D(12, 13, emissive);

// gamma to linear
vec3 g2l(vec3 g)
{
    return g * (g * (g * 0.305306011 + 0.682171111) + 0.012522878);
}

// combined hdr to ldr and linear to gamma
vec3 l2g(vec3 l)
{
    return sqrt(1.33 * (1. - exp(-l))) - 0.03;
}

vec3 fresnel_schlick_roughness(float prod, vec3 F0, float roughness)
{
    return F0 + (max(F0, 1. - roughness) - F0) * pow(1. - prod, 5.);
}

vec2 brdf_approx(float Roughness, float NoV)
{
    const vec4 c0 = vec4(-1., -0.0275, -0.572, 0.022);
    const vec4 c1 = vec4(1., 0.0425, 1.04, -0.04);
    vec4 r = Roughness * c0 + c1;
    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
    return AB;
}

void main()
{
    vec4 base_opacity = texture(BNB_SAMPLER_2D(base_color), var_uv);

    vec3 base = g2l(base_opacity.xyz);
    float opacity = base_opacity.w;

    vec3 mrao = texture(BNB_SAMPLER_2D(metallic_roughness), var_uv).xyz;

    float metallic = mrao.z;
    float roughness = mrao.y;
    float ao = mrao.x;

    vec3 N = normalize(mat3(var_t, var_b, var_n) * (texture(BNB_SAMPLER_2D(normal), var_uv).xyz * 2. - 1.));
    N *= gl_FrontFacing ? 1. : -1.;

    vec3 V = normalize(-var_v);
    float cN_V = max(0., dot(N, V));
    vec3 R = reflect(-V, N);

    vec3 F0 = mix(vec3(0.04), base, metallic);

    vec3 F = fresnel_schlick_roughness(cN_V, F0, roughness);
    vec3 kD = (1. - F) * (1. - metallic);

    vec3 diffuse = texture(BNB_SAMPLER_CUBE(tex_ibl_diff), N).xyz * base;

    const float MAX_REFLECTION_LOD = 7.; // number of mip levels in tex_ibl_spec
    vec3 prefilteredColor = textureLod(BNB_SAMPLER_CUBE(tex_ibl_spec), R, roughness * MAX_REFLECTION_LOD).xyz;
    vec2 brdf = brdf_approx(roughness, cN_V);
    vec3 specular = prefilteredColor * (F0 * brdf.x + brdf.y);

    vec3 color = (kD * diffuse * ao + specular);

    color += g2l(texture(BNB_SAMPLER_2D(emissive), var_uv).xyz);

    bnb_FragColor = vec4(l2g(color), opacity);
}
#include <bnb/glsl.vert>
#include <bnb/matrix_operations.glsl>
#include <bnb/decode_int1010102.glsl>

layout(location = 0) in vec3 attrib_pos;
#if defined(BNB_VK_1)
layout(location = 1) in uint attrib_n;
layout(location = 2) in uint attrib_t;
#else
layout(location = 1) in vec4 attrib_n;
layout(location = 2) in vec4 attrib_t;
#endif
layout(location = 3) in vec2 attrib_uv;
layout(location = 4) in uvec4 attrib_bones;
layout(location = 5) in vec4 attrib_weights;

BNB_DECLARE_SAMPLER_2D(10, 11, bnb_BONES);

BNB_OUT(0)
vec2 var_uv;
BNB_OUT(1)
vec3 var_t;
BNB_OUT(2)
vec3 var_b;
BNB_OUT(3)
vec3 var_n;
BNB_OUT(4)
vec3 var_v;

#include <bnb/anim_transform.glsl>

void main()
{
    mat4 m = bnb_get_transform();
    vec3 vpos = (vec4(attrib_pos, 1.) * m).xyz;

    gl_Position = bnb_MVP * vec4(vpos, 1.);

    var_uv = attrib_uv;

    mat3 mv0_3 = mat3(bnb_MV[0].xyz, bnb_MV[1].xyz, bnb_MV[2].xyz);
    mat3 m_3 = mat3(m[0].xyz, m[1].xyz, m[2].xyz);

    vec4 attrib_t1 = decode_int1010102(attrib_t);
    vec4 attrib_n1 = decode_int1010102(attrib_n);

    var_t = normalize(mv0_3 * (attrib_t1.xyz * m_3));
    var_n = normalize(mv0_3 * (attrib_n1.xyz * m_3));
    var_b = attrib_t1.w * cross(var_n, var_t);
    var_v = (bnb_MV * vec4(vpos, 1.)).xyz;
}
#include <bnb/glsl.frag>

precision mediump float;
precision mediump sampler2DArray;
precision mediump sampler2DShadow;

BNB_IN(0)
vec2 var_uv;
BNB_IN(1)
vec3 var_t;
BNB_IN(2)
vec3 var_b;
BNB_IN(3)
vec3 var_n;
BNB_IN(4)
vec3 var_v;

BNB_DECLARE_SAMPLER_2D(0, 1, diffuse);
BNB_DECLARE_SAMPLER_2D(2, 3, spec_gloss);
BNB_DECLARE_SAMPLER_2D(4, 5, normal);
BNB_DECLARE_SAMPLER_CUBE(6, 7, tex_ibl_diff);
BNB_DECLARE_SAMPLER_CUBE(8, 9, tex_ibl_spec);
BNB_DECLARE_SAMPLER_2D(12, 13, emissive);

// gamma to linear
vec3 g2l(vec3 g)
{
    return g * (g * (g * 0.305306011 + 0.682171111) + 0.012522878);
}

// combined hdr to ldr and linear to gamma
vec3 l2g(vec3 l)
{
    return sqrt(1.33 * (1. - exp(-l))) - 0.03;
}

vec3 fresnel_schlick_roughness(float prod, vec3 F0, float roughness)
{
    return F0 + (max(F0, 1. - roughness) - F0) * pow(1. - prod, 5.);
}

vec2 brdf_approx(float Roughness, float NoV)
{
    const vec4 c0 = vec4(-1., -0.0275, -0.572, 0.022);
    const vec4 c1 = vec4(1., 0.0425, 1.04, -0.04);
    vec4 r = Roughness * c0 + c1;
    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
    return AB;
}

void main()
{
    vec4 diffuse_opacity = texture(BNB_SAMPLER_2D(diffuse), var_uv);

    vec3 diffuse_color = g2l(diffuse_opacity.xyz);
    float opacity = diffuse_opacity.w;

    vec4 specular_glossiness = texture(BNB_SAMPLER_2D(spec_gloss), var_uv);
    vec3 F0 = g2l(specular_glossiness.xyz);

    float roughness = 1. - specular_glossiness.w;

    vec3 N = normalize(mat3(var_t, var_b, var_n) * (texture(BNB_SAMPLER_2D(normal), var_uv).xyz * 2. - 1.));
    N *= gl_FrontFacing ? 1. : -1.;

    vec3 V = normalize(-var_v);
    float cN_V = max(0., dot(N, V));
    vec3 R = reflect(-V, N);

    vec3 F = fresnel_schlick_roughness(cN_V, F0, roughness);
    vec3 kD = 1. - F;

    vec3 diffuse_lighting = texture(BNB_SAMPLER_CUBE(tex_ibl_diff), N).xyz * diffuse_color;

    const float MAX_REFLECTION_LOD = 7.; // number of mip levels in tex_ibl_spec
    vec3 prefilteredColor = textureLod(BNB_SAMPLER_CUBE(tex_ibl_spec), R, roughness * MAX_REFLECTION_LOD).xyz;
    vec2 brdf = brdf_approx(roughness, cN_V);
    vec3 specular = prefilteredColor * (F0 * brdf.x + brdf.y);

    vec3 color = (kD * diffuse_lighting + specular);

    color += g2l(texture(BNB_SAMPLER_2D(emissive), var_uv).xyz);

    bnb_FragColor = vec4(l2g(color), opacity);
}
#include <bnb/glsl.vert>
#include <bnb/matrix_operations.glsl>
#include <bnb/decode_int1010102.glsl>

layout(location = 0) in vec3 attrib_pos;
#if defined(BNB_VK_1)
layout(location = 1) in uint attrib_n;
layout(location = 2) in uint attrib_t;
#else
layout(location = 1) in vec4 attrib_n;
layout(location = 2) in vec4 attrib_t;
#endif
layout(location = 3) in vec2 attrib_uv;
layout(location = 4) in uvec4 attrib_bones;
layout(location = 5) in vec4 attrib_weights;

BNB_DECLARE_SAMPLER_2D(10, 11, bnb_BONES);

BNB_OUT(0)
vec2 var_uv;
BNB_OUT(1)
vec3 var_t;
BNB_OUT(2)
vec3 var_b;
BNB_OUT(3)
vec3 var_n;
BNB_OUT(4)
vec3 var_v;

#include <bnb/anim_transform.glsl>

void main()
{
    mat4 m = bnb_get_transform();
    vec3 vpos = (vec4(attrib_pos, 1.) * m).xyz;

    gl_Position = bnb_MVP * vec4(vpos, 1.);

    var_uv = attrib_uv;

    mat3 mv0_3 = mat3(bnb_MV[0].xyz, bnb_MV[1].xyz, bnb_MV[2].xyz);
    mat3 m_3 = mat3(m[0].xyz, m[1].xyz, m[2].xyz);

    vec4 attrib_t1 = decode_int1010102(attrib_t);
    vec4 attrib_n1 = decode_int1010102(attrib_n);

    var_t = normalize(mv0_3 * (attrib_t1.xyz * m_3));
    var_n = normalize(mv0_3 * (attrib_n1.xyz * m_3));
    var_b = attrib_t1.w * cross(var_n, var_t);
    var_v = (bnb_MV * vec4(vpos, 1.)).xyz;
}
#include <bnb/glsl.frag>

BNB_IN(0)
vec2 var_uv;

BNB_DECLARE_SAMPLER_2D(0, 1, s);

void main()
{
    float THRESHOLD = light_streak_threshold.x;
    vec3 c = textureLod(BNB_SAMPLER_2D(s), var_uv, 0.).xyz;
    float intensity = dot(c, vec3(0.299, 0.587, 0.114));
    bnb_FragColor = vec4(intensity * step(THRESHOLD, intensity));
}#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_pos;

BNB_OUT(0)
vec2 var_uv;

void main()
{
    vec2 v = attrib_pos;
    gl_Position = vec4(v, 0., 1.);
    var_uv = v * 0.5 + 0.5;
#ifdef BNB_VK_1
    var_uv.y = 1. - var_uv.y;
#endif
}#include <bnb/glsl.frag>

centroid BNB_IN(0) vec2 var_c;

void main()
{
    bnb_FragColor = vec4(var_c, 0., 0.);
}#include <bnb/glsl.vert>

layout(location = 0) in vec3 attrib_pos;
#if defined(BNB_VK_1)
layout(location = 1) in uint attrib_n;
layout(location = 2) in uint attrib_t;
#else
layout(location = 1) in vec4 attrib_n;
layout(location = 2) in vec4 attrib_t;
#endif
layout(location = 3) in vec2 attrib_uv;
layout(location = 4) in uvec4 attrib_bones;
layout(location = 5) in vec4 attrib_weights;

BNB_DECLARE_SAMPLER_2D(0, 1, bnb_UVMORPH);
BNB_DECLARE_SAMPLER_2D(2, 3, bnb_STATICPOS);

centroid BNB_OUT(0) vec2 var_c;

void main()
{
    const int EXPAND_PASSES = 8;
    const float NPUSH = 75.;

    int i = int(gl_InstanceID);

    float scale = 1. - float(i) / float(EXPAND_PASSES + 1);
    scale = scale * scale * (3. - 2. * scale); // smoothstep fall-off
    float d0 = float(i) / float(EXPAND_PASSES + 1);
    float d1 = float(i + 1) / float(EXPAND_PASSES + 1);
#ifndef BNB_VK_1
    vec4 npush_scale = vec4(NPUSH * float(i) / float(EXPAND_PASSES), scale * 0.5 * MORPH_WEIGHT, d1 - d0, d0 + d1 - 1.);
#else
    vec4 npush_scale = vec4(NPUSH * float(i) / float(EXPAND_PASSES), scale * 0.5 * MORPH_WEIGHT, (d1 - d0) * 0.5, (d0 + d1) * 0.5);
#endif
    const float max_range = 40.;
    vec3 translation = textureLod(BNB_SAMPLER_2D(bnb_UVMORPH), smoothstep(0., 1., attrib_uv), 0.).xyz * (2. * max_range) - max_range;
    vec3 vpos = attrib_pos + translation;

    gl_Position = bnb_MVP * vec4(vpos * (1. + npush_scale.x / length(vpos)), 1.);
    gl_Position.z = gl_Position.z * npush_scale.z + gl_Position.w * npush_scale.w;

    vec4 pos_no_push = bnb_MVP * vec4(vpos, 1.);
    vec2 uv = attrib_uv;
#ifndef BNB_VK_1
    uv.y = 1.0 - uv.y;
#endif
    vec3 static_pos = textureLod(BNB_SAMPLER_2D(bnb_STATICPOS), uv, 0.).xyz;
    vec4 original_pos = bnb_MVP * vec4(static_pos + translation, 1.);
    var_c = npush_scale.y * (original_pos.xy / original_pos.w - pos_no_push.xy / pos_no_push.w);
}#include <bnb/glsl.frag>

BNB_DECLARE_SAMPLER_2D(0, 1, tex_warp);
BNB_DECLARE_SAMPLER_2D(2, 3, tex_frame);

BNB_IN(0)
vec2 var_uv;

void main()
{
    vec2 o = textureLod(BNB_SAMPLER_2D(tex_warp), var_uv, 0.).xy;
#if defined(BNB_VK_1)
    o = vec2(o.x, -o.y);
#endif
    bnb_FragColor = textureLod(BNB_SAMPLER_2D(tex_frame), var_uv + o, 0.);
}
#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_v;

BNB_DECLARE_SAMPLER_2D(0, 1, tex_warp);

BNB_OUT(0)
vec2 var_uv;

void main()
{
    vec2 v = attrib_v * 0.5 + 0.5;

#if defined(BNB_VK_1)
    const float bottom_coord = 1.;
    const float top_coord = 0.;
#else
    const float bottom_coord = 0.;
    const float top_coord = 1.;
#endif

    float bottom_margin = 0.;
    bottom_margin = max(bottom_margin, -textureLod(BNB_SAMPLER_2D(tex_warp), vec2(0.25, bottom_coord), 0.).y);
    bottom_margin = max(bottom_margin, -textureLod(BNB_SAMPLER_2D(tex_warp), vec2(0.50, bottom_coord), 0.).y);
    bottom_margin = max(bottom_margin, -textureLod(BNB_SAMPLER_2D(tex_warp), vec2(0.75, bottom_coord), 0.).y);

    float top_margin = 0.;
    top_margin = max(top_margin, textureLod(BNB_SAMPLER_2D(tex_warp), vec2(0.25, top_coord), 0.).y);
    top_margin = max(top_margin, textureLod(BNB_SAMPLER_2D(tex_warp), vec2(0.50, top_coord), 0.).y);
    top_margin = max(top_margin, textureLod(BNB_SAMPLER_2D(tex_warp), vec2(0.75, top_coord), 0.).y);

    float left_margin = 0.;
    left_margin = max(left_margin, -textureLod(BNB_SAMPLER_2D(tex_warp), vec2(0., 0.25), 0.).x);
    left_margin = max(left_margin, -textureLod(BNB_SAMPLER_2D(tex_warp), vec2(0., 0.50), 0.).x);
    left_margin = max(left_margin, -textureLod(BNB_SAMPLER_2D(tex_warp), vec2(0., 0.75), 0.).x);

    float right_margin = 0.;
    right_margin = max(right_margin, textureLod(BNB_SAMPLER_2D(tex_warp), vec2(1., 0.25), 0.).x);
    right_margin = max(right_margin, textureLod(BNB_SAMPLER_2D(tex_warp), vec2(1., 0.50), 0.).x);
    right_margin = max(right_margin, textureLod(BNB_SAMPLER_2D(tex_warp), vec2(1., 0.75), 0.).x);

    float size_x = 1. - left_margin - right_margin;
    float size_y = 1. - bottom_margin - top_margin;

    float scale;
    if (size_x > size_y) {
        scale = 1. / size_y;
        left_margin += (size_x - size_y) * 0.5;
    } else {
        scale = 1. / size_x;
        bottom_margin += (size_y - size_x) * 0.5;
    }
    gl_Position = vec4((v - vec2(left_margin, bottom_margin)) * scale * 2. - 1., 0., 1.);

    var_uv = v;
#if defined(BNB_VK_1)
    var_uv.y = 1. - var_uv.y;
#endif
}#include <bnb/glsl.frag>

BNB_IN(0)
vec2 var_uv;
BNB_IN(1)
vec2 var_draw_id;

// kernel: 0.028532	0.067234	0.124009	0.179044	0.20236	0.179044	0.124009	0.067234	0.028532
const float s0 = 0.20236;
const float s1 = 0.124009 + 0.179044;
const float s2 = 0.028532 + 0.067234;

BNB_DECLARE_SAMPLER_2D(0, 1, s_color_source);

void main()
{
    int d = int(var_draw_id.x);

    float inv_sz = 1. / bnb_MORPH_BLUR_PASS_HEIGHT;

    if (d == 0) {
        inv_sz *= bnb_SCREEN.y / bnb_SCREEN.x;
    }

    float o1 = inv_sz * (1. + 0.179044 / s1);
    float o2 = inv_sz * (3. + 0.067234 / s2);

    vec2 uv1p = var_uv;
    vec2 uv1m = var_uv;

    vec2 uv2p = var_uv;
    vec2 uv2m = var_uv;

    if (d == 0) {
        uv1p[0] += o1;
        uv1m[0] -= o1;
        uv2p[0] += o2;
        uv2m[0] -= o2;
    } else {
        uv1p[1] += o1;
        uv1m[1] -= o1;
        uv2p[1] += o2;
        uv2m[1] -= o2;
    }

    vec2 o_blurred = s0 * textureLod(BNB_SAMPLER_2D(s_color_source), var_uv, 0.).xy
                     + s1 * (textureLod(BNB_SAMPLER_2D(s_color_source), uv1p, 0.).xy + textureLod(BNB_SAMPLER_2D(s_color_source), uv1m, 0.).xy)
                     + s2 * (textureLod(BNB_SAMPLER_2D(s_color_source), uv2p, 0.).xy + textureLod(BNB_SAMPLER_2D(s_color_source), uv2m, 0.).xy);

    bnb_FragColor = vec4(o_blurred, 0, 1.);
}#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_v;

BNB_OUT(0)
vec2 var_uv;
BNB_OUT(1)
vec2 var_draw_id;
void main()
{
    vec2 v = attrib_v;
    gl_Position = vec4(v, 0., 1.);
    var_uv = v * 0.5 + 0.5;
    var_draw_id = vec2(float(fxr_DrawID), 0.);
#if defined(BNB_VK_1)
    var_uv.y = 1. - var_uv.y;
#endif
}#include <bnb/glsl.frag>
#include <bnb/lut.glsl>

BNB_IN(0)
vec3 maskColor;
BNB_IN(1)
vec4 var_uv_bg_uv;

BNB_DECLARE_SAMPLER_LUT(0, 1, lookupTexTeeth);
BNB_DECLARE_SAMPLER_LUT(2, 3, lookupTexEyes);

BNB_DECLARE_SAMPLER_2D(4, 5, tex_softLight);
BNB_DECLARE_SAMPLER_2D(6, 7, tex_normalMakeup);
BNB_DECLARE_SAMPLER_2D(8, 9, bnb_BACKGROUND);


vec3 whitening(vec3 originalColor, float factor, BNB_DECLARE_SAMPLER_LUT_ARGUMENT(lookup))
{
    vec3 color = BNB_TEXTURE_LUT(originalColor, BNB_PASS_SAMPLER_ARGUMENT(lookup));
    return mix(originalColor, originalColor, factor);
}


vec3 sharpen(vec3 originalColor, float factor)
{
    const float dx = 1.0 / 960.0;
    const float dy = 1.0 / 1280.0;

    vec3 total = 5.0 * originalColor
                 - textureLod(BNB_SAMPLER_2D(bnb_BACKGROUND), vec2(var_uv_bg_uv.z - dx, var_uv_bg_uv.w - dy), 0.).xyz
                 - textureLod(BNB_SAMPLER_2D(bnb_BACKGROUND), vec2(var_uv_bg_uv.z + dx, var_uv_bg_uv.w - dy), 0.).xyz
                 - textureLod(BNB_SAMPLER_2D(bnb_BACKGROUND), vec2(var_uv_bg_uv.z - dx, var_uv_bg_uv.w + dy), 0.).xyz
                 - textureLod(BNB_SAMPLER_2D(bnb_BACKGROUND), vec2(var_uv_bg_uv.z + dx, var_uv_bg_uv.w + dy), 0.).xyz;

    vec3 result = mix(originalColor, total, factor);
    return clamp(result, 0.0, 1.0);
}


vec3 softSkin(vec3 originalColor, float factor)
{
    vec3 screenColor = originalColor;

    const float dx = 4.5 / 960.0;
    const float dy = 4.5 / 1280.0;

    vec3 nextColor0 = textureLod(BNB_SAMPLER_2D(bnb_BACKGROUND), vec2(var_uv_bg_uv.z - dx, var_uv_bg_uv.w - dy), 0.).xyz;
    vec3 nextColor1 = textureLod(BNB_SAMPLER_2D(bnb_BACKGROUND), vec2(var_uv_bg_uv.z + dx, var_uv_bg_uv.w - dy), 0.).xyz;
    vec3 nextColor2 = textureLod(BNB_SAMPLER_2D(bnb_BACKGROUND), vec2(var_uv_bg_uv.z - dx, var_uv_bg_uv.w + dy), 0.).xyz;
    vec3 nextColor3 = textureLod(BNB_SAMPLER_2D(bnb_BACKGROUND), vec2(var_uv_bg_uv.z + dx, var_uv_bg_uv.w + dy), 0.).xyz;

    float intensity = screenColor.g;
    vec4 nextIntensity = vec4(nextColor0.g, nextColor1.g, nextColor2.g, nextColor3.g);
    vec4 lg = nextIntensity - intensity;

    vec4 curr = max(0.367 - abs(lg * (0.367 * 0.6 / (1.41 * PSI.x))), 0.);

    float summ = 1.0 + curr.x + curr.y + curr.z + curr.w;
    screenColor += (nextColor0 * curr.x + nextColor1 * curr.y + nextColor2 * curr.z + nextColor3 * curr.w);
    screenColor = screenColor * (factor / summ);

    screenColor = originalColor * (1. - factor) + screenColor;
    return screenColor;
}


float softlight_blend_1ch(float a, float b)
{
    return ((1. - 2. * b) * a + 2. * b) * a;
}


vec3 blendSoftLight(vec3 base, vec3 blend)
{
    return vec3(softlight_blend_1ch(base.r, blend.r), softlight_blend_1ch(base.g, blend.g), softlight_blend_1ch(base.b, blend.b));
}


void main()
{
    vec3 res = textureLod(BNB_SAMPLER_2D(bnb_BACKGROUND), var_uv_bg_uv.zw, 0.).xyz;
    res = softSkin(res, maskColor.r * skinSoftIntensity.x);

    if (maskColor.g > 1. / 255.) {
        float sharp_factor = maskColor.g * teethSharpenIntensity.x;
        res = sharpen(res, sharp_factor);
        float teeth_factor = maskColor.g;
        res = whitening(res, teeth_factor, BNB_PASS_SAMPLER_ARGUMENT(lookupTexTeeth));
    }

    res = sharpen(res, maskColor.b * eyesSharpenIntensity.x);
    res = whitening(res, maskColor.b * eyesWhiteningCoeff.x, BNB_PASS_SAMPLER_ARGUMENT(lookupTexEyes));
    // vec2 uvh = vec2(abs(2.0 * (var_uv_bg_uv.x - 0.5)), var_uv_bg_uv.y);
    res.xyz = blendSoftLight(res.xyz, texture(BNB_SAMPLER_2D(tex_softLight), var_uv_bg_uv.xy).xyz);
    vec4 makeup2 = texture(BNB_SAMPLER_2D(tex_normalMakeup), var_uv_bg_uv.xy);
    res.xyz = mix(res.xyz, makeup2.xyz, makeup2.w);

    bnb_FragColor = vec4(res, 1.);
}#include <bnb/glsl.vert>

layout(location = 0) in vec3 attrib_pos;
layout(location = 1) in vec3 attrib_pos_static;
layout(location = 2) in vec2 attrib_uv;
layout(location = 3) in vec4 attrib_red_mask;

BNB_OUT(0)
vec3 maskColor;
BNB_OUT(1)
vec4 var_uv_bg_uv;

invariant gl_Position;

void main()
{
    gl_Position = bnb_MVP * vec4(attrib_pos, 1.);
    maskColor = attrib_red_mask.xyz;
    vec2 bg_uv = (gl_Position.xy / gl_Position.w) * 0.5 + 0.5;
    var_uv_bg_uv = vec4(attrib_uv, bg_uv);

#ifdef BNB_VK_1
    var_uv_bg_uv.w = 1. - var_uv_bg_uv.w;
#endif
}#include <bnb/glsl.frag>

BNB_IN(0)
vec3 pos_static;

void main()
{
    bnb_FragColor = vec4(pos_static, 1.);
}#include <bnb/glsl.vert>

layout(location = 0) in vec3 attrib_pos;
layout(location = 1) in vec2 attrib_uv;

BNB_OUT(0)
vec3 pos_static;

void main()
{
    vec2 v = attrib_uv * 2. - 1.;
    v.y = -v.y;
    gl_Position = vec4(v, 0., 1.);
    pos_static = attrib_pos;
}#include <bnb/glsl.frag>

BNB_IN(0)
vec3 translation;

void main()
{
    bnb_FragColor = vec4(translation, 1.);
}#include <bnb/glsl.vert>

layout(location = 0) in vec3 attrib_pos;
layout(location = 1) in vec3 attrib_static_pos;
layout(location = 2) in vec2 attrib_uv;
layout(location = 3) in vec4 attrib_mask;

BNB_OUT(0)
vec3 translation;

void main()
{
    vec2 v = smoothstep(0., 1., attrib_uv) * 2. - 1.;
    gl_Position = vec4(v, 0., 1.);
    const float max_range = 40.; // morph translation will be clamped to [-max_range,+max_range]
    translation = ((attrib_pos - attrib_static_pos) / max_range) * 0.5 + 0.5;
}#include <bnb/glsl.frag>

#include <bnb/texture_bicubic.glsl>


BNB_IN(0)
vec2 var_uv;
BNB_IN(1)
vec2 var_bg_uv;

BNB_DECLARE_SAMPLER_2D(0, 1, s_bg_texture);
BNB_DECLARE_SAMPLER_2D(2, 3, s_src_texture);

void main()
{
    vec4 bg_color_mask = textureLod(BNB_SAMPLER_2D(s_src_texture), var_uv, 0.);
    vec3 bg_color = bg_color_mask.rgb;
    float mask = 1. - bg_color_mask.a;
    vec2 uv = var_bg_uv;

    vec2 uv_coeff = step(vec2(0.0, 0.0), uv) - step(vec2(1., 1.), uv);

    vec4 bg_tex_color = texture(BNB_SAMPLER_2D(s_bg_texture), uv);
    bg_tex_color.rgb *= uv_coeff.x * uv_coeff.y;

    bnb_FragColor = vec4(
        mix(bg_color, bg_tex_color.rgb, mask * bg_tex_color.a),
        clamp(vbg_tex_size_a.w * bg_tex_color.a, (1. - mask), 1.)
    );
}
#include <bnb/glsl.vert>

layout(location = 0) in vec2 attrib_pos;

BNB_OUT(0)
vec2 var_uv;
BNB_OUT(1)
vec2 var_bg_uv;

#include <bnb/transform_uv.glsl>

void main()
{
    vec2 v = attrib_pos;
    gl_Position = vec4(v, 0., 1.);
    var_uv = v * 0.5 + 0.5;
    var_bg_uv = var_uv;

#ifdef BNB_VK_1
    var_uv.y = 1. - var_uv.y;
    var_bg_uv.y = 1. - var_bg_uv.y;
#endif

    vec2 bg_tex_size = vbg_tex_size_a.xy;

    if (vbg_tex_size_a.x < 1.0 || vbg_tex_size_a.y < 1.0) {
        bg_tex_size = bnb_SCREEN.xy;
    }

    float background_rotation_angle = 0.;
    background_rotation_angle += vbg_scale_rot_mode.z;

    float degrees_to_radians = 0.017453292;
#ifdef BNB_VK_1
    degrees_to_radians *= -1.0;
#endif

    var_bg_uv = bnb_rotate_uv(var_bg_uv, degrees_to_radians * (background_rotation_angle));
    var_bg_uv = bnb_scale_uv(var_bg_uv, vbg_scale_rot_mode.xy);
    var_bg_uv = bnb_contain_uv(var_bg_uv, bg_tex_size, vbg_scale_rot_mode.w, background_rotation_angle);

#ifndef BNB_VK_1
    var_bg_uv.y = 1. - var_bg_uv.y;
#endif
}
#ifndef BNB_LUT_GLSL
#define BNB_LUT_GLSL

/**
 * Following defines
 * `vec4 BNB_TEXTURE_LUT(vec4 original_color, BNB_DECLARE_SAMPLER_LUT_ARGUMENT(lookup_texture))`,
 * Where `lookup_texture` defined as
 * `BNB_DECLARE_SAMPLER_LUT(x, y) lookup_texture;`.
 * You can apply this LUT using following code:
 * `vec4 res = BNB_TEXTURE_LUT(original_color, BNB_PASS_SAMPLER_ARGUMENT(lookup_texture));`.
 * `vec3` overload is also present.
 */
#define BNB_DECLARE_SAMPLER_LUT(binding_index_1, binding_index_2, sampler_name) BNB_DECLARE_SAMPLER_3D(binding_index_1, binding_index_2, sampler_name)
#define BNB_DECLARE_SAMPLER_LUT_ARGUMENT(lookup_texture) BNB_DECLARE_SAMPLER_3D_ARGUMENT(lookup_texture)
#define BNB_TEXTURE_LUT bnb_texture_3d_lookup_512
#define BNB_TEXTURE_LUT_SMALL bnb_texture_3d_lookup_16
#define BNB_TEXTURE_LUT_LOD BNB_TEXTURE_3D_LOD

#define BNB_SAMPLER_LUT BNB_PASS_SAMPLER_ARGUMENT

/**
 * Appply LUT to `original_color`. `lookup_texture` must be square 512x512
 * 2D texture.
 * https://docs.unrealengine.com/en-US/RenderingAndGraphics/PostProcessEffects/UsingLUTs/index.html
 * Prefer `BNB_TEXTURE_LUT` instead of this call.
 */
vec4 bnb_texture_lookup_512(
    vec4 original_color,
    BNB_DECLARE_SAMPLER_2D_ARGUMENT(lookup_texture)
)
{
    const float epsilon = 0.000001;
    const float lut_size = 512.0;

    float blue_value = (original_color.b * 255.0) / 4.0;

    vec2 mul_b = clamp(floor(blue_value) + vec2(0.0, 1.0), 0.0, 63.0);
    vec2 row = floor(mul_b / 8.0 + epsilon);
    vec4 row_col = vec4(row, mul_b - row * 8.0);
    vec4 lookup = original_color.ggrr * (63.0 / lut_size)
                  + row_col * (64.0 / lut_size) + (0.5 / lut_size);

    float factor = blue_value - mul_b.x;

    vec3 sampled1 = textureLod(
                        BNB_SAMPLER_2D(lookup_texture),
                        lookup.zx,
                        0.
    )
                        .rgb;
    vec3 sampled2 = textureLod(
                        BNB_SAMPLER_2D(lookup_texture),
                        lookup.wy,
                        0.
    )
                        .rgb;

    vec3 res = mix(sampled1, sampled2, factor);
    return vec4(res, original_color.a);
}

vec3 bnb_texture_lookup_512(
    vec3 original_color,
    BNB_DECLARE_SAMPLER_2D_ARGUMENT(lookup_texture)
)
{
    return bnb_texture_lookup_512(
               vec4(original_color, 1.0),
               BNB_PASS_SAMPLER_ARGUMENT(lookup_texture)
    )
        .rgb;
}

/**
 * Appply LUT to `original_color`. `lookup_texture` must be 16x256
 * 2D texture.
 * https://docs.unrealengine.com/en-US/RenderingAndGraphics/PostProcessEffects/UsingLUTs/index.html
 * Prefer `BNB_TEXTURE_LUT` instead of this call.
 */
vec4 bnb_texture_lookup_16x256(
    vec4 original_color,
    BNB_DECLARE_SAMPLER_2D_ARGUMENT(lookup_texture)
)
{
    float blue_value = original_color.b * 15.;
    float blue_plane = floor(blue_value);
    float factor = blue_value - blue_plane;
    vec2 uv = original_color.rg * vec2(15. / 16., 15. / 256.) + vec2(0.5 / 16., 0.5 / 256.);
    uv.y += blue_plane / 16.;
    vec3 sampled1 = textureLod(BNB_SAMPLER_2D(lookup_texture), uv, 0.).rgb;
    uv.y += 1. / 16.;
    vec3 sampled2 = textureLod(BNB_SAMPLER_2D(lookup_texture), uv, 0.).rgb;

    vec3 res = mix(sampled1, sampled2, factor);
    return vec4(res, original_color.a);
}

vec3 bnb_texture_lookup_16x256(
    vec3 original_color,
    BNB_DECLARE_SAMPLER_2D_ARGUMENT(lookup_texture)
)
{
    return bnb_texture_lookup_16x256(vec4(original_color, 1.0), BNB_PASS_SAMPLER_ARGUMENT(lookup_texture)).rgb;
}

/**
 * Prefer `BNB_TEXTURE_LUT` instead of this call.
 */
vec4 bnb_texture_3d_lookup_512(vec4 original_color, BNB_DECLARE_SAMPLER_3D_ARGUMENT(lookup_texture))
{
    return vec4(textureLod(BNB_SAMPLER_3D(lookup_texture), original_color.rgb * (63. / 64.) + 0.5 / 64., 0.).rgb, original_color.a);
}

vec3 bnb_texture_3d_lookup_512(vec3 original_color, BNB_DECLARE_SAMPLER_3D_ARGUMENT(lookup_texture))
{
    return textureLod(BNB_SAMPLER_3D(lookup_texture), original_color * (63. / 64.) + 0.5 / 64., 0.).rgb;
}

vec4 bnb_texture_3d_lookup_16(vec4 original_color, BNB_DECLARE_SAMPLER_3D_ARGUMENT(lookup_texture))
{
    return vec4(textureLod(BNB_SAMPLER_3D(lookup_texture), original_color.rgb * (15. / 16.) + 0.5 / 16., 0.).rgb, original_color.a);
}

vec3 bnb_texture_3d_lookup_16(vec3 original_color, BNB_DECLARE_SAMPLER_3D_ARGUMENT(lookup_texture))
{
    return textureLod(BNB_SAMPLER_3D(lookup_texture), original_color * (15. / 16.) + 0.5 / 16., 0.).rgb;
}

#endif // BNB_LUT_GLSL#ifndef BNB_MATRIX_OPERATIONS_GLSL
#define BNB_MATRIX_OPERATIONS_GLSL

mat3 bnb_inverse_trs2d(mat3 m)
{
    vec2 s = 1. / vec2(dot(vec2(m[0].x, m[1].x), vec2(m[0].x, m[1].x)), dot(vec2(m[0].y, m[1].y), vec2(m[0].y, m[1].y)));
    mat2 r = transpose(mat2(m[0].xy * s, m[1].xy * s));
    vec2 t = -(vec2(m[0].z, m[1].z) * r);
    return mat3(vec3(r[0], t.x), vec3(r[1], t.y), vec3(0., 0., 1.));
}

float bnb_mat2_as_vec4_determinant(vec4 m)
{
    return m.x * m.w - m.y * m.z;
}

#endif#ifndef BNB_MORPH_TRANSFORM_GLSL
#define BNB_MORPH_TRANSFORM_GLSL

#ifdef BNB_USE_AUTOMORPH
vec2 bnb_morph_coord(vec3 v)
{
    const float half_angle = radians(104.);
    const float y0 = -110.;
    const float y1 = 112.;
    float x = atan(v.x, v.z) / half_angle;
    float y = ((v.y - y0) / (y1 - y0)) * 2. - 1.;
    return vec2(x, y);
}

    #ifndef BNB_AUTOMORPH_BONE
vec3 bnb_auto_morph(vec3 v)
{
    vec2 morph_uv = bnb_morph_coord(v) * 0.5 + 0.5;
        #ifdef BNB_VK_1
    morph_uv.y = 1. - morph_uv.y;
        #endif
    vec3 translation = textureLod(BNB_SAMPLER_2D(bnb_MORPH), morph_uv, 0.).xyz;
    return v + translation;
}
    #else
vec3 bnb_auto_morph_bone(vec3 v, mat4 m)
{
    vec2 morph_uv = bnb_morph_coord(vec3(m[0][3], m[1][3], m[2][3])) * 0.5 + 0.5;
        #ifdef BNB_VK_1
    morph_uv.y = 1. - morph_uv.y;
        #endif
    vec3 translation = textureLod(BNB_SAMPLER_2D(bnb_MORPH), morph_uv, 0.).xyz;
    return v + translation;
}
    #endif // BNB_AUTOMORPH_BONE
#endif     // BNB_USE_AUTOMORPH
#endif     // BNB_MORPH_TRANSFORM_GLSL#ifndef BNB_QUAT_ROTATION
#define BNB_QUAT_ROTATION

vec3 bnb_quat_rotate(vec4 q, vec3 v)
{
    return v + 2. * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float bnb_quat_to_side_euler(vec4 quat, float isMirroredCoeff, float initAngle)
{
    float angle = initAngle;
    vec4 q = quat;

    q.x = -q.x;
    q.y = -q.y;

    vec3 side = bnb_quat_rotate(q, vec3(1., 0., 0.));
    vec3 up = bnb_quat_rotate(q, vec3(0., 1., 0.));

    if (side.y > 0.7071 && bnb_SCREEN.x < bnb_SCREEN.y) {
        angle += 90. * isMirroredCoeff;
    } else if (side.y < -0.7071 && bnb_SCREEN.x < bnb_SCREEN.y) {
        angle += -90. * isMirroredCoeff;
    } else if (up.y < -0.7071 && bnb_SCREEN.x < bnb_SCREEN.y) {
        angle += 180.;
    }

    return angle;
}

vec4 bnb_quat_mul(vec4 q0, vec4 q1)
{
    float A = (q0.w + q0.x) * (q1.w + q1.x);
    float C = (q0.w - q0.x) * (q1.y + q1.z);
    float D = (q0.y + q0.z) * (q1.w - q1.x);
    float B = (q0.z - q0.y) * (q1.y - q1.z);
    float E = (q0.x + q0.z) * (q1.x + q1.y) * 0.5;
    float F = (q0.x - q0.z) * (q1.x - q1.y) * 0.5;
    float G = (q0.w + q0.y) * (q1.w - q1.z) * 0.5;
    float H = (q0.y - q0.w) * (q1.w + q1.z) * 0.5;
    return vec4(
        A - E + H - (F + G),
        C - F + E + (G + H),
        D - G + E - (F + H),
        B - H + G - (F + E)
    );
}

vec4 bnb_quat_conjugate(vec4 q)
{
    return vec4(-q.x, -q.y, -q.z, q.w);
}

#endif#ifndef BNB_SAMPLE_CAMERA_GLSL
#define BNB_SAMPLE_CAMERA_GLSL

vec4 bnb_sample_camera(vec2 uv)
{
    vec4 result;
    if (bnb_rgba_camera.x < 0.5) {
        float Y = textureLod(BNB_SAMPLER_2D(tex_y), uv, 0.).x;

        if (bnb_camera_scale_i420.y < 0.5) {
            vec2 UV = textureLod(BNB_SAMPLER_2D(tex_uv), uv, 0.).xy;
            result = vec4(Y, UV.x, UV.y, 1.) * bnb_conversion_matrix;
        } else {
            float U = textureLod(BNB_SAMPLER_2D(tex_u), uv, 0.).x;
            float V = textureLod(BNB_SAMPLER_2D(tex_v), uv, 0.).x;

            result = vec4(Y, U, V, 1.) * bnb_conversion_matrix;
        }
    } else {
        result = textureLod(BNB_SAMPLER_2D(tex_rgb), uv, 0.);
        if (bnb_rgba_camera.z > 0.5) {
            result = result.bgra; // BGRA
        } else if (bnb_rgba_camera.w > 0.5) {
            result = result.gbar; // ARGB
        }
    }
    return result;
}

#endif // BNB_SAMPLE_CAMERA_GLSL#ifndef BNB_SAMPLERS_DECLARATION_GLSL
#define BNB_SAMPLERS_DECLARATION_GLSL


// clang-format off

#ifdef BNB_VK_1
    #define BNB_DECLARE_SAMPLER_2D(binding_index_1, binding_index_2, sampler_name) layout(set = 1, binding = binding_index_1) uniform texture2D texture_##sampler_name;layout(set = 1, binding = binding_index_2) uniform sampler sampler_##sampler_name

    #define BNB_DECLARE_SAMPLER_2D_ARRAY(binding_index_1, binding_index_2, sampler_name) layout(set = 1, binding = binding_index_1) uniform texture2DArray texture_##sampler_name; layout(set = 1, binding = binding_index_2) uniform sampler sampler_##sampler_name

    #define BNB_DECLARE_SAMPLER_CUBE(binding_index_1, binding_index_2, sampler_name) layout(set = 1, binding = binding_index_1) uniform textureCube texture_##sampler_name;layout(set = 1, binding = binding_index_2) uniform sampler sampler_##sampler_name

    #define BNB_DECLARE_SAMPLER_3D(binding_index_1, binding_index_2, sampler_name) layout(set = 1, binding = binding_index_1) uniform texture3D texture_##sampler_name; layout(set = 1, binding = binding_index_2) uniform sampler sampler_##sampler_name

    #define BNB_DECLARE_SAMPLER_2D_ARGUMENT(arg_name) texture2D texture_##arg_name, sampler sampler_##arg_name
    #define BNB_DECLARE_SAMPLER_2D_ARRAY_ARGUMENT(arg_name) texture2DArray texture_##arg_name, sampler sampler_##arg_name
    #define BNB_DECLARE_SAMPLER_CUBE_ARGUMENT(arg_name) textureCube texture_##arg_name, sampler sampler_##arg_name
    #define BNB_DECLARE_SAMPLER_3D_ARGUMENT(arg_name) texture3D texture_##arg_name, sampler sampler_##arg_name

    #define BNB_PASS_SAMPLER_ARGUMENT(arg_name) texture_##arg_name, sampler_##arg_name

#else
    #define BNB_DECLARE_SAMPLER_2D(binding_index_1, binding_index_2, sampler_name) uniform sampler2D sampler_name
    #define BNB_DECLARE_SAMPLER_2D_ARRAY(binding_index_1, binding_index_2, sampler_name) uniform sampler2DArray sampler_name
    #define BNB_DECLARE_SAMPLER_CUBE(binding_index_1, binding_index_2, sampler_name) uniform samplerCube sampler_name
    #define BNB_DECLARE_SAMPLER_3D(binding_index_1, binding_index_2, sampler_name) uniform sampler3D sampler_name

    #define BNB_DECLARE_SAMPLER_2D_ARGUMENT(arg_name) sampler2D arg_name
    #define BNB_DECLARE_SAMPLER_2D_ARRAY_ARGUMENT(arg_name) sampler2DArray arg_name
    #define BNB_DECLARE_SAMPLER_CUBE_ARGUMENT(arg_name) samplerCube arg_name
    #define BNB_DECLARE_SAMPLER_3D_ARGUMENT(arg_name) sampler3D arg_name

    #define BNB_PASS_SAMPLER_ARGUMENT(arg_name) arg_name
#endif

#define BNB_DECLARE_SAMPLER_VIDEO(binding_index_1, binding_index_2, sampler_name) BNB_DECLARE_SAMPLER_2D(binding_index_1, binding_index_2, sampler_name)

// clang-format on

#endif // BNB_SAMPLERS_DECLARATION_GLSL#ifndef BNB_TEXTURE_BICUBIC_GLSL
#define BNB_TEXTURE_BICUBIC_GLSL

#include <bnb/textures_lookup.glsl>

vec4 cubic(float v)
{
    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;
    vec4 s = n * n * n;
    float x = s.x;
    float y = s.y - 4.0 * s.x;
    float z = s.z - 4.0 * s.y + 6.0 * s.x;
    float w = 6.0 - x - y - z;
    return vec4(x, y, z, w) * (1.0 / 6.0);
}

vec4 bnb_texture_bicubic(BNB_DECLARE_SAMPLER_2D_ARGUMENT(tex), vec2 uv)
{
    vec2 tex_size = vec2(textureSize(BNB_SAMPLER_2D(tex), 0));
    vec2 invtex_size = 1.0 / tex_size;

    uv = uv * tex_size - 0.5;

    vec2 fxy = fract(uv);
    uv -= fxy;

    vec4 xcubic = cubic(fxy.x);
    vec4 ycubic = cubic(fxy.y);

    vec4 c = uv.xxyy + vec2(-0.5, +1.5).xyxy;

    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);
    vec4 offset = c + vec4(xcubic.yw, ycubic.yw) / s;

    offset *= invtex_size.xxyy;

    vec4 sample0 = textureLod(BNB_SAMPLER_2D(tex), offset.xz, 0.);
    vec4 sample1 = textureLod(BNB_SAMPLER_2D(tex), offset.yz, 0.);
    vec4 sample2 = textureLod(BNB_SAMPLER_2D(tex), offset.xw, 0.);
    vec4 sample3 = textureLod(BNB_SAMPLER_2D(tex), offset.yw, 0.);

    float sx = s.x / (s.x + s.y);
    float sy = s.z / (s.z + s.w);

    return mix(
        mix(sample3, sample2, sx),
        mix(sample1, sample0, sx),
        sy
    );
}

#endif // BNB_TEXTURE_BICUBIC_GLSL
#ifndef BNB_TEXTURES_LOOKUP_GLSL
#define BNB_TEXTURES_LOOKUP_GLSL

#define BNB_TEXTURE_2D(s, uv) texture(s, vec2(uv)) // NOTE: effect converter reqiure cast uv to vec2
#define BNB_TEXTURE_2D_ARRAY texture
#define BNB_TEXTURE_2D_LOD textureLod
#define BNB_TEXEL_FETCH_2D texelFetch
#define BNB_TEXTURE_CUBE texture
#define BNB_TEXTURE_CUBE_LOD textureLod
#define BNB_TEXTURE_3D texture
#define BNB_TEXTURE_3D_LOD textureLod
#define BNB_CENTROID centroid

#if defined(BNB_GL_ES_3) || defined(BNB_GL)
    #define BNB_SAMPLER_2D(sampler_name) sampler_name
    #define BNB_SAMPLER_2D_ARRAY(sampler_name) sampler_name
    #define BNB_SAMPLER_CUBE(sampler_name) sampler_name
    #define BNB_SAMPLER_3D(sampler_name) sampler_name
#elif defined(BNB_VK_1)
    #define BNB_SAMPLER_2D(sampler_name) sampler2D(texture_##sampler_name, sampler_##sampler_name)
    #define BNB_SAMPLER_2D_ARRAY(sampler_name) sampler2DArray(texture_##sampler_name, sampler_##sampler_name)
    #define BNB_SAMPLER_CUBE(sampler_name) samplerCube(texture_##sampler_name, sampler_##sampler_name)
    #define BNB_SAMPLER_3D(sampler_name) sampler3D(texture_##sampler_name, sampler_##sampler_name)
#endif

#endif // BNB_TEXTURES_LOOKUP_GLSL
#ifndef BNB_TRANSFORM_UV
#define BNB_TRANSFORM_UV
// https://gist.github.com/ayamflow/c06bc0c8a64f985dd431bd0ac5b557cd
vec2 bnb_rotate_uv(vec2 uv, float rotation)
{
    const float mid = 0.5;

    return vec2(
        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,
        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid
    );
}

vec2 bnb_scale_uv(vec2 uv, vec2 scale)
{
    const float mid = 0.5;

    scale = 1. / scale;

    return (uv - mid) * scale + mid;
}

const float aspect_scale_to_fill = 0.;
const float aspect_fill = 1.;
const float aspect_fit = 2.;


bool bnb_float_eq(float a, float b, float prec)
{
    if (sign(a) != sign(b)) {
        return false;
    }

    return abs(sign(a) * a - sign(b) * b) < prec;
}


bool bnb_float_eq(float a, float b)
{
    return bnb_float_eq(a, b, 0.0001);
}


vec2 bnb_contain_uv(vec2 uv, vec2 tex_size, float content_mode, float angle)
{
    const float mid = 0.5;
    float tex_aspect = tex_size.x / tex_size.y;
    if (bnb_float_eq(angle, 90., 0.1) || bnb_float_eq(angle, -90., 0.1) || bnb_float_eq(angle, 270., 0.1) || bnb_float_eq(angle, -270., 0.1)) {
        tex_aspect = tex_size.y / tex_size.x;
    }

    float screen_aspect = bnb_SCREEN.x / bnb_SCREEN.y;

    float ratio = tex_aspect / screen_aspect;

    float x = 1.;
    float y = 1.;

    if (bnb_float_eq(content_mode, aspect_fill, 0.1)) {
        if (bnb_float_eq(angle, 90., 0.1) || bnb_float_eq(angle, -90., 0.1) || bnb_float_eq(angle, 270., 0.1) || bnb_float_eq(angle, -270., 0.1)) {
            if (ratio > 1.) {
                y /= ratio;
            } else {
                x *= ratio;
            }
        } else {
            if (ratio > 1.)
                x /= ratio;
            else
                y *= ratio;
        }
        // } else if (content_mode == aspect_scale_to_fill) {
        // this is the default GL behaviuor, skip the `if` entirely
    } else if (bnb_float_eq(content_mode, aspect_fit, 0.1)) {
        if (bnb_float_eq(angle, 90., 0.1) || bnb_float_eq(angle, -90., 0.1) || bnb_float_eq(angle, 270., 0.1) || bnb_float_eq(angle, -270., 0.1)) {
            if (ratio > 1.) {
                x *= ratio;
            } else {
                y /= ratio;
            }
        } else {
            if (ratio > 1.)
                y *= ratio;
            else
                x /= ratio;
        }
    }

    return vec2(x, y) * (uv - mid) + mid;
}
#endif#ifndef BNB_VERSION_GLSL
#define BNB_VERSION_GLSL

#ifdef GL_ES
    #define BNB_GL_ES_3 1
#else
    #ifdef VULKAN
        #define BNB_VK_1 1
    #else
        #define BNB_GL 1
    #endif
#endif

#endif // BNB_VERSION_GLSL
var Api = require('bnb_js/legacy.js')

var effect;

var world = {
    landmarks: [],
    latents: []
};

function configure(newEffect)
{
    effect = newEffect;
    effect.init();
}


function onFRXUpdate(strLandmarks, strLatents)
{
    world.landmarks = strLandmarks ? strLandmarks : [];
    world.latents = strLatents ? strLatents : [];

    for (var i = 0; i < effect.faceActions.length; i++) {
        effect.faceActions[i]();
    }
}

function onUpdate()
{
    for (var i = 0; i < effect.noFaceActions.length; i++) {
        effect.noFaceActions[i]();
    }
}

function onVideoRecordStart()
{
    var i;
    for (i = 0; i < effect.videoRecordStartActions.length; i++) {
        effect.videoRecordStartActions[i]();
    }
}

function onVideoRecordFinish()
{
    var i;
    for (i = 0; i < effect.videoRecordFinishActions.length; i++) {
        effect.videoRecordFinishActions[i]();
    }
}

function onVideoRecordDiscard()
{
    var i;
    for (i = 0; i < effect.videoRecordDiscardActions.length; i++) {
        effect.videoRecordDiscardActions[i]();
    }
}


isMouthOpen = Api.isMouthOpen;
isSmile = Api.isSmile;
isEyebrowUp = Api.isEyebrowUp;
isDisgust = Api.isDisgust;
getEyesStatus = Api.getEyesStatus;

//too many false positives for now
//isEyebrowUpSpecialFunction = isEyebrowUp;
//isEyebrowUpSpecialHint = "Raise eyebrows";
isEyebrowUpSpecialFunction = isSmile;
isEyebrowUpSpecialHint = "Smile";


function jsonToApi(json, api)
{
    var obj = JSON.parse(json)
    for (var key in api)
    {
        var methodName = key
        var propertyName = api[key] 
        if (obj.hasOwnProperty(propertyName))
        {
            Api[methodName](obj[propertyName])
        }
    }
}

// Duktape on Android doesn't support function overloading.
// We do it on JS side for Api.meshfxMsg.

if (Api.getPlatform() == "android") {
    Api.native_meshfxMsg = Api.meshfxMsg;
    Api.meshfxMsg = function(param1, param2, param3, param4) {
        if (param3 == undefined && param4 == undefined) {
            Api.native_meshfxMsg(param1, param2, 0, "");
        } else if (param4 == undefined) {
            Api.native_meshfxMsg(param1, param2, param3, "");
        } else {
            Api.native_meshfxMsg(param1, param2, param3, param4);
        }
    }
}

if (Api.getCurrentTimeNs() != 0) {
    Date.prototype.getTime = function() {
        return Api.getCurrentTimeNs() * 1e-6;
    } 
    Api.print("Using overriding Date.getTime() implementation.");
    Api.print("getTime() value is: " + (new Date()).getTime());
}
0.38.2 cml/coreMLOcclusion.mlmodelc
0.38.2 cml/coreMLFace.mlmodelc
0.38.2 cml/coreMLPaint.mlmodelc
0.38.2 cml/coreMLEyes_v3.mlmodelc
0.38.2 cml/coreMLSkin.mlmodelc
0.38.2 cml/coreMLFaceSkin.mlmodelc
0.38.2 cml/coreMLBrows.mlmodelc
0.38.2 cml/coreMLHair_336x192.mlmodelc
0.38.2 cml/acne.mlmodelc
0.38.2 cml/bags.mlmodelc
1.4.0 cml/coreMLLips.mlmodelc
0.38.2 cml/coreMLNails.mlmodelc
1.7.0 cml/coreMLBGPortraitLow.mlmodelc
1.7.0 cml/coreMLBGLandscapeLow.mlmodelc
1.7.0 cml/coreMLBGPortraitHigh.mlmodelc
1.7.0 cml/coreMLBGLandscapeHigh.mlmodelc
1.6.0 flow/eyes_segmentation.tflite
0.38.2 flow/hand_detector.tflite
0.38.2 flow/hair_vert.tflite
0.38.2 flow/bg_vert.tflite
1.1.0 flow/hair_lite_horiz.tflite
1.1.0 flow/hair_lite_vert.tflite
1.2.0 flow/hair_lite_horiz_heavy.tflite
1.2.0 flow/hair_lite_vert_heavy.tflite
0.38.2 flow/bg_high_vert.tflite
0.38.2 flow/hair_horiz.tflite
1.6.0 flow/skin_segm.tflite
1.3.0 flow/face_segm.tflite
1.4.0 flow/landmarks_contour_filter.tflite
1.4.0 flow/landmarks_lips_filter.tflite
1.5.0 flow/landmarks_contour.tflite
1.7.0 flow/landmarks_contour_prior.tflite
1.5.0 flow/landmarks_contour_medmask.tflite
1.7.0 flow/landmarks_contour_lite.tflite
1.5.0 flow/landmarks_lips.tflite
1.7.0 flow/landmarks_lips_fast.tflite
1.5.0 flow/landmarks_lips_medmask.tflite
1.7.0 flow/landmarks_eyes.tflite
1.7.0 flow/landmarks_224.tflite
0.38.2 flow/hand_skelet.tflite
1.4.0 flow/frx_prior.tflite
0.38.2 flow/body_segm.tflite
1.8.0 flow/lips_segmentation.tflite
0.38.2 flow/hand_gestures.tflite
1.7.1 flow/bg_lite_vert.tflite
1.7.0 flow/face_detector_online.tflite
1.7.0 flow/face_detector_offline.tflite
1.7.0 flow/face_detector_multiface_offline.tflite
1.5.0 flow/bg_landscape.tflite
1.7.0 flow/bg_landscape_lite.tflite
1.5.0 flow/neck_segmentation.tflite
1.6.0 flow/fingers/i_closer1.tflite
1.6.0 flow/fingers/i_closer2.tflite
1.6.0 flow/fingers/m_closer1.tflite
1.6.0 flow/fingers/m_closer2.tflite
1.6.0 flow/fingers/r_closer1.tflite
1.6.0 flow/fingers/r_closer2.tflite
1.6.0 flow/fingers/s_closer2.tflite
1.6.0 flow/fingers/s_closer2.tflite
1.8.0 flow/watch/wrist_st1_mv2_a050_clean.h5.tflite
1.8.0 flow/watch/wrist_st2_256p_v2_norm.h5.tflite
1.8.0 flow/watch/wrist_st4_a050.h5.tflite
1.8.0 flow/vision_gelu_tanh_float16.tflite
1.8.0 flow/acne.tflite
1.8.0 flow/paint.tflite
5.0.0 other_assets
PNG

   IHDR      J   c=-  wPLTE   (her$ 3-b^l-);)$7`\j50B|[WeTP_GCSC?PXTcKGX>:Kwtro{ebo84EmjwOL[p2   EtRNS ZG<~qly3vaE7i?S/J'$*N\^Z  IDAThv@@KDTE	nDM.e9/j&iMa-l~32/a4*mNI8U6\.lj<*JX{|RVW@p,!'=&sQ%L>jPD8-k*V4^dfeMyq>l6ify</ :GDBXj0!uU(U>t-L9=@Hj&^6FQU3:pPv"	$^M}	Ug	IQ&#Bc'Zi0/t;vXV(\
Z1!%.0!*'q:;@aB9!-eg#Ca6tf?w!q9eX (`.#SygnKU\`[$on.YIt9Z(c 3huhVf4ByZkX JQiu#(PLf,4l[Io] =tG$r$TX}h/	s:-\_B,U!bIg &e5IHqQT$Dctp8G2:+?G2C6BRkHKmRw3pjDZvgvb&*j/DBx,lYI
zc:fNCY_uhsH
U?P(wUj 6XKuD,+	LA/& BOdHeU>B&	A`9'k`YHB"gG5!N^~8y&:+w?S ;*y%?[12N2p;wd
}OC+3Q{1UQq-BDo?ofHi_DQ8.JM*nX ZuEg!; _?w|k'!HH!sg<k[BRx$KcAF)]cyhzpq		k~	f qH8iW!8~&Zu9+v.^|FTL 1Jc) cmRB*=100"}#0'TI<}1f&bm;jO[O\
}6 &SjZ!?C}]b$y%U]q.\.+J m9bx6\B0z(%MRkiG?ZFDbwn
w-
sBs Qgeji<#mE-t*mm=n mDF2="I/hdzI/xCqei	FU`cd'r[GdcU3BhS^zcq&t &GC9XpKy%8UXc/C7-90|!]T6k})y9)QBr|^%K0qf'Z\={&nu]m&s=k&L
&y0,G>LhsFFr<3W"n$m[	Uy1E'x1+a!Lti)H::jT3<:sfHrc4a /#yS)9!y s}/"XAX?">`!>&J]<v9V"/Vvy0Y ]    IENDB`PNG

   IHDR  P         PLTE   v   tRNS 
(.$%!24081<+7,&>""*D 4B@6+B<:GIJ' FEL;O:SVQYLZ^[@CfM<t]V~tHHGjC"TNJzg30&aa]B7z7,rbT<^XTHwmke.`NLA;2&l_Z|ytR,lkYMMqd9fpf<XR"y]  SQIDATxMj@2RdD\R\}qe2=AMwYtU*'9,}n4~x c'I$I$I$I$I$Im'Ak-f\~(@ra/=lB{ZUZk
Z souNUG/8\}yp@>z/th]dW7w6><a/u(}y_Z]tt >z/@tf{FQyx{\ToxUx<.0N#}xp~|_xE|qkdYiY,{$;]ly_{{{x#"2$DJg#5OeN7`#5Oge5=JWoy#;=dg-`7a?W%cw<xS~>%0w?I;QG0;^Wy_cTOE|y_G0y_G0y_G0y_G0y_G0y_Ox_F/54]O/djBJb$"
Jh,A`z*)X4-H*6 "
)x$*<x:7:I6Yf64+Nb0ab;ACy<<Q-5c;AAKbV9qLefSw%y,XoC,e cFZxtCRi xKe0m %FJGj~?xyeIbX$)aCQ	*I:8	4UR$>UX0$yz4sc*ol/>Y85wxPP8(.:+nLX_>NDcvN*.y<?wWy8N-Lq&e .qn`h(. Ws].Ul2;7Eo}b.=&*~+F|z@46w&w-ECU/)'[m(1#V Q(fH]dZ3;8~B}&x7q.m_o8
IH@*j;pK5pD'E;P8Ez+C]
Gu0+
/fpy}y)q>gAM{w_g9[]$59aJj1L~ogkk?HOw;yz= vz/s$4iq870,zIj}lA\w5C:n*:@w<3%+819.N^[$i]%u .Q$FK3yNl	9.B%-mH\`hiavn9a Ynhg]xw||An[u\$EfHde,OA>j{JGD	6bs$o%[P7i	C:K
fS#^`w:s78GE:cyI>UTtskAg.sxGEu[&@\cs1/}M:}p&CW?(r>S>lwF\"u3-h>xId_%15e;GQ\diKQ(mPjf9jD#L*3OUQC4#wM@I"*C8~-
j|VAnGtXBS)6
LH4LT)?<o8%)%p7[myr.}=}Fq9ypn?!sEH=sR1~;gO5mn8>/Ee	rk</;=Rs1[H]t_pL]Ye~utdggYwf]
<_bDQTT<P"xAAD+DQD/UwoWL"W_u>uHX
+m1tHE/xo]_}w
B4+aVw>s?.N ~a/"'O'Irl=w><sod=B]i{M+f/0Alt3fZ8qs=](xPoz>r8aj}\N~xON?'LO#}&?*KKnE@0,us{>S4zTgtV'`#=WqCec>gnz2>Qf YDo#w9/awv
T6F]zt:I$g/Rm/FZ<y~#<)
_2pu\t46g h='`z #,#bcZ75q?wON_#d>jQl)nGtF|,2+S,u1RBv|M[O-Qe`(-Y6+9^	 axQ:ci2]j$m?n%7d= z0l1[lQ^tlEJGF[WFr#:)
-1|6e$0U_z5a^8t:j_n\	M vXT@ja0XC!.P[!7&dD%p_j	# V_<&T}_]+
dbt-I9fl0}!7LW&XmH%Mv=cXw#"J{|=U)kBZ5ReRuov(lp7]	Bi@V;
Pydoi_"ho+G l-]h~X{<yJn9{('Y)2\E+ #P,dW
]v[dx*+Q"pPO-<Joi"&^ ?wQ9sg3@Yl@tlX{:"1o4-B@ U5?
=)|IHvOJ~],F-]I)Om3@wy%PjU'FT+xB:@5Yl4Fu 8:8>s=^.L!=^Bp
?67$g9+D]1R)e
>wGP 9jb  xm8Zg	5kl=lI!()%x?@*jbF=CQ0rfb7'!/Nu`ay~OY~N(]AFw!ZVB'O :|]nRxPee )%xT~fH,]G(
hsExt1I5#W_ty'u7+aFm(=e7|bo,&~e]3RP.P6rjq|vFMZ08 ?J@$i6-tH@pG,Z	S$l>o"~rU5ngmpA-AVsH"XP#<OZf;zcZ,LU|MKIhpZ'[vf/N';IT/5tW>^.`R@8"%/OUx mZm/TND"B7g3<)4IoBpV%odz{g}m!/L(uj	w/%GQ 2@[aP#~! "#zR2q
{zxL<k04XZb7wf]SsoDsWaIP	B`wCJ"9	^o^P(j[H9pD=.K}>e0459x{a ;1YP
FFOB(7BAW<x%+cCx<ovy/X*8F8?PD#4L|1{BPzFx
%}58% B8~[c#/'
~*c^5T$?8
pP8P8Y`Qz/^FV)[PhbiB(}R
uacxBA
}mBnyz\`@E(h,1_WwQtBvCaK<.']BEX"\N)RM#hB))W=MPCSr3&zdy5?uJ"4;n~aK$T#DqU!FJum'pe F|!p~0ECY|+-]+G!}8u3p
O2S	$y	KAP^~98't#A8Y N$	f.10Ko5reBPB#Ywnn>JRU$(zIr\_9'
M5/)KNY}	q)pBqdq<@pXIBEc	Gz<`/B*Ll*fJk
qn"'nxO<n!4	XJ"U#rkmj^zT#`Co4"s7.n];;9&F8)(*J+  !*!$.q) @E(WZ? qrCW	$~ v2Ox73\:5Yr-95uQ:A29m~9,(u/Lq!&7'h&3C\9Z?{XE+nf[,#.g{>_[gKR<anGX1cNCA_)N,w6F}D21/%f!z$ bKP'@<`~<%P#:N\ve9+u\'4s6z(9U|&UGhNAu|X9XdKp<usd//D^t^hgc@$	2e"*5f,A
aKV.N\Py/,x3e1)	BJ$F|V=9'xO.,d"*mhOHs4I)&	Cvgg(zvN?Gh@W2BbXMHZ#;,wA J:	AvfEZ*[|w;.3w`9_6)LY~1].9^
gd-2C	oUy_SvaG@$QqYs${mE9ts!6%gi$m1B&Fh_Hrivx;a;N /3M=@<9F*y1^9DR:{+$\M)oQTY85GW "`+tl3(\8EQXKf1E7Ik~N=iqYn]LAG"^A_m9Iyv*b&E=mri-Ff{nd\Hz&}A8e=noE,$I
+:X1+L"N7U8:A9De}83gg
e6UocPS1((AudP&ylH!fSS[(Z)m<;zE-8@pQd}obyA'MK\j'J<GGmY~!'J@)0{>X:vdBV87)-?Oz%P\mhY;tj3..'yn@>)(%\ 2LNe[t$t%:C&M`UV^U;5(doN~^By~$RN4]
/dnD7$~Q@bM=&%Vr:iY_Xk;|V={E"nmP9.e"mq{O>7<[2m4)A3]nQ^406#$hhL+cP-p iz:	:8cGRXl0.Gmd+S-2{!LF+3(slm>CN5:f+p.x.aKf#2FS2j"Ra6PFAd-D<*;	el[0o9@ux%vvg|/ 0W sZDzH9AA*L(,p'mvSs;wjP&nz_zGvn!jBC#jiPH2$\.YN7Q9&9VHBA9uQaQ+|(3s{4p.E}kmPjE%}oEdbT QJH1%3)sU rJmEmF +Lh;b_Me&(gP<8zSH YlQ0nKQ^\<9C*H/K>H
e\S*4nx=2,SBG;V/c<]@cEP"TcdUZiFW vp1P>g`E~nE\0(I@FG{l[PMbXQQfebhRZvvKW
La;bmxB{[wlPRoIfI s^RO=B:R*w.~)wV=] kj>9?[2eELm8uTO9XEQ3U`/t9tloCWWuDzkuSnD&.Or{*v`}[>De#"g$(oYI(9	$U/PL2;)8K7XgJ4 Wj\q(fQ2.0k/\Ip2#g<V)$"{
P\}]A/W\]oka g$T3rmOWnIdU$Q3!Uh#uFp{|/^tzb]C^)r|!vH=dIHO1omjI?D33lQD1{jnE2.vM><r:lm\F;sGPu!s*b<1f|>eG9||bIZ<)uGre]	xKbu?_sl9lF*	X0
M`QXYQDzj~Qt|ubXAfLHUOILEZdO9te^< ))l= y+OQ/rKeo<$\ira$GhWP6dC;b6rtDeF^+``Pu(~(ya`w|iYxg'd{?B|NgjE\Y"T1crG0v,IUw3*Isu;N];S.
>)]p	rEB=:ZSN#{PzDgw`(KK{EuFmp	vpW^rKI7.BE){CI;vWv1k<"TT/LO?P~gs(D\ <CAs{JYxi/0#_  IK.trRb)2%.64M:raHP:zC)wu7(!!b44eY^zHOAnn (i
QHVNL:ftp} S(qbd:x2"50!: i/ 	27]C1O^`4` --^\6tCVG?0ZMV ],$:0d,!B2b 	`	oATeC$1@+4?irW\KlFWM/,MDn.f7]`HVamSEl+*p
q$B?Hk ostw")04^h9dHP=4M65Ko`shdSkeh3p!}-{A(`9H|	c{SRK{s,|nHOb1%6rl$:$bh*e HVZ<0)5IFA$>I QWd|"{aD7UQ&Q|-;4{4vZ4t$hw>P @<4>Pq[0*ZPN6C"%;LY.yo=dHAU	Fy-Cd0]Bf+C4:OfDJ"oO2$${7
N1lm4t i-Y [iA94w=$:d/B7T?nt[j$+'E"`Y&<D6$EE\||6hn`4]v{&$qm5eN8%z\HfSj],Y&V,A|F|	V7 lA_'$N     FPUUUUUUUalra(!H69Da'&V'U&g{X,bX,.cB1JVMest%K 6&0W9)a`gu-)?k4zbG-a-^K23Q
xKTIom_EznbY2h\c9*dbSVaA|pJPgA= `joyruV(uIgj0ebM<OkJfERpc5qy|`F	*E:%HI)7R*FLA)*6h6xM*Q@9/7cA?KHaURp0)'(A)++h ,yL!_qxCTe@6 ]1fIUsWWT&Ts2Vbk[LLl\o sHR,!ID&_;OY2MyKEap}|S?)s<'sHd3d()!<L!yg}s]^k}[e]V#EYe,\3J3YbV[EW6Pag(aPnC8eboEnq,;`\T/drf?m_d
Spxwam>.rq=9LH<vG=~h`B;:=zK%9]0{e@5|tiP;7U:`;D)#  (&+$#*<1l-}wM@w#3O3g<lUhmd~HlEX$G	@
-6o=te3xVJYsYGX{;yhz!&FB{v!w9;:0]$"KTVR\_^OTg0}q;>n|_1rGzBVPF]/I'XX0eF57v^=oJrQ61
>EHok2,$-03# 1Wylc8D^%w6jsRV}I.(mqPP.OF(%eK+qcGJA7,+;+/-)q>3WALfS@gs1U>MpKG-mkKTj-k#OxPt^LWV
Yz*~'QH)>;&\Yhm@[
6x)Koqu3*5Bq\[x<W@oXyq[<!nC|sl.0J7FuKM5sXIN5@Q1	et2DvQi.D|/*(m"Y]N`{lWz_>[21F(Q.D?XnLx}s
[FTaE4=oMG3Z,A# hG&-DIy0S2rE)jlfD2kVqPOh&xX+vPx0 U#vz}DM~1a]`c4(A" f'aDQhx?4M>A3{!T=)<+B}vM2oxq`H!rQ\D
@OP8. *NT9t+Wy.0]tP2Z[u*yF(j3,3
,6a)*H#MNT_Y}s/IW1zVd%`vv[I|OM6)b gwm3N3;q.*%tK,S$Pv=[ITy
uu^G4lpJ(3%TtF(Tjd.k@O1Np-uF#9J*@)=F&qJrM%cXyjYZA*E49q*oa:CR	;SRT4B%}mR3	ESf^P%?R5*jy0W7-Vh&	b^:j#qJ#Ty!B~jrr1O(L(UBVG	20-yB2r"(;D/+0K:PHZsEPjZ-}W)o=vh.J,(c<zz5:3LmgGn, NR;VA74XWI&}#{z~D}HheD Ke1Tdkz[qzSUT'% E?KdS3)4~.rtG(j'9M|\`?tB(kr0F)"T(G"%fM&JVFT.Pad Sq,)A(kGS
Jrh%)Q>;&JInkTU&*W^+{8<z ,Q9+^p@.X^U.K	A'}o;)Sj(P\z&Xz	q9#i2TP#TQ2<|hICI&`QD!C:(FBPPbX*K"Ds:{@uvxEi1,]*[&IcthdV3*	>Uj}*@QB^1BT.dUmmpWdJT2(G7Bq*P6|| x#SQRR~,i4BYLP<G(@Y$Tp!MhH-gk4x(`E]d LYYKhEdJ0mQ5rQS5BU;jiyd'(-hV2hagGg^LdUrXwpTQKoQQMe*YM+e&Ldx?]x@2DnWxT*P6+_(QN(P3]c%7D_WS}R\vqYYxU7^)@j
yqN@YT:],kUbD!8& l^#7;4d(_^3Kap)$dI]R(	IBA|`,s\<s[\y	J:K6U0T3iD4^6AOI!/b	?*82YY?;rK\DWmF U#rz4;@v>[-%H tY@|
T.24Grgib)+)@ui4>mK@)ON*b!l6u	K wVbdJ1<q\,>`B
\2	P8ZhQQO5u{"5JOXRwv@I"3 %<.i<u<7be"T8t=6=Y'ubxT<f0r
tE*c4 UUmY
dI(^WKL<U=*)YLRizP=zQALgT|lN
&%AUK;p07d>~n2
`b	xT>Z& 1g$FtM&(*D(Gh
 >u&[*wr*MuHU
@k%!}Uj*lAuZ)J/_ B=+`_x5Z%Y^SJ9QecYv\7$Ps>H*P{qz7<yr %P>"c}Up2'%nJ2 jT0
9B)\re(P$lpg :t;_::9h_<JeE.(Y		eQV[PScb *JDN:0MK:2{o:7(cs?>no(Z(WK=w%nPj:sSRC]urOQrq;~z:l1EZ9+%@ee'^h.(nOVwru1&Q6P gg[LH?U
~sHEGifEDdN9Pn	<m3v(P	BkPYr`-oq=%Nc>:R2>9tM{ o@U99N7$UF5
FwP,"r=b/gC?uNP5@ist^Y.Yl"@>xp3g\~E(9 TLVn*]P~K
[4iV@:ng)# -P!W"O+u8c|	mN2ycB*CI>5j9m[+594@(srR|F&=_#Ebka-UU]vx}[U$A
qh@L*eF+
.[tT|Ar=md
_TJ~YKnhYPF9Q`'*,;ro?fm BmjiRU6+j{H,<u\WvTbNNN /tNVmTVodW*[;o@kjw)Il%<ZM&r]Tz1E1Jj ?IFF:g=wA
bTWy((rM{z_#2wShe14c;(<j}r /vR4^|lr,<U^dEi S!(dX9]958IjQ/gFcmiT$b@]DI4U;lkLa@ubf4$ EAyCWu
2,PO@5G^Mc;?.!>5RDYz+[h	@mvEj;?fIL~nt?"7%D/|bF9u<@GW>ZC~ph(ioqWCBZsZ0oLgB2I15\JKn:]6SPyEr] f?zosIsL>W(jXR}+mP\txtJ
{)1r+mpTlFf$'(HuxRCc5rA%*JcW/U(U^T*t%.QL[CC`s9o 8043l/VmQUKP6J@)UexeqJh<qlFgde9}3p+j m1@s81nz~S^z9 Z"+BE9T*'
7P,fQ[Rm))/yvO.YyL$R[jf`)X%wE6`VQ hij%\
Jf"mZsABm#-P_^q0D"@iZY@DUSpd d52b%sBQF2)+dG""(W$eD2"[=uz}ssDxdg"RTm.hRdUiRL2=I1Ji"FLi\'V?i)MffoYErg2uJ5\7x6v-ZR*eTe	( %EhSTX[.#{Zd oHlI+  8(6ZUmQ:4 rY2`]T=V!M-1#YcV",0j8}0jz b9IVIbYr|B$P0r.msPFpSPn%YAJoX3/K5?U^]w,:P)wfOPV'gZn>@wnV`Bnh?\+$]jR8PdUzC*[m4SeI5x)Y3sDAVJ"h) 5Sb]dF JC gs<K/!([Y) 5 x}23$m;-BP&JU
K^gLe^0Dq0ZGf-j6=2akx8cV7 aLp",72(	~M5B7!U<n[@6Y)Op</nP*45vwh4j6<"J;y~UqbSCEz (DeD>_kBUG9pu@	P(jB0WE tD{q>JMq Z%2\RP,6-T~C^<zBD>E=2tq}EHe@oSn2|TJ2 iQBSCbC\WAwOYlN"A(!O]E9}{Cy6vJCJ.[k4[&&3MPdd4o.N>aq unv# LU.@"j4 1i 5.[G Ry(C'jYY~m>
8C6sWg+if(s9L?1L.)OT$wP8yG~'/Xrd=Ts;0A^M$lwWh,c# \,.KMUG:2WvCFnRc5i~zCU*5S#D\T:3?Q`8aY~eyyY.=z~	d	Q`-c{B1k,OnC]{yl's,Ny&zOM
t9}f]r,(n(n	F3<Bk&(MNVw
CTuMij5b,@q/88^:k}M>d"zh=lQ}oNWt]~R?V~
zqF_3p8e!CTBrlP{~zsR{LN2QQ~u67[A3 K4KTE{KY<(o_+l&BYE{SKhEL@"Ffb'Dc,>Xa-."L];oVn5KL@7u-o`-ga|}u_6!~Pi]L@1h?l\A:X=z,RV<'cYppTQm0Oo1leqZ7IqUd0+<1B-	RgH$:J N-j1+4yNz<g 	&5B;.YISEUV7	RT i>Agf&Qvd4VEw#i7Wmb*![@m,t>sE0u] &QX#/HN<7&U:aA;z.CG/RE=pRVy$mPr+k]8NNk@30qXc{w OzU9&D%k01o;%.INx!?
(Iz^;v'>fqTl0_[n_5HxT0V=i1_E.xY#[ICW+Y>${_n	Xdm"G&=5,BMV$4OrVnxCqc,/F2b 4z2xvRnbY%|oMP |_+:lJbYRHL]+ ?	tGW$0r1^CT2*k3I~QvQ1= qXl.+\NNLr{XtrG6i2JPIVT0=d'IL\]$V/(Q,o2@A4[@`Q"w1:7{Pg
uvY.1@ZiolqX]QK8t '^|:v[@GH@,7/"T"]W3lp'tH	d=eEkEW5=^m=bt#k'LHu9qZ/Pn@Kui4r@ylr>`>Na/=u0Oe-^WAo^$6xA/FSpN{, 9!xf/o-<xH4nht^'29zo4U~Ma+wKr-%zk'|=ooMa:Orj^s5X7rA qEyV[{QYb~bv@NVx\<YBQjR!-Wdob1_-=0TuSl|oqe;n~XpFo1UXY?tT5T4L%/Ts4U_UvI9e;mB,N(?'s{S$a9L8&4z:%(Mna!9Y^
@O,Ag 2"6mD-'!~_YG= ~.1."Y~NFNA?f/$5\rjQ_O} 6$<=|7'X
jq}`>yZ"eUZ22-2QW\90m3Z1*3\2s.b#r(8+XdPg'_D0%puzU*,2k@0%,rD6=V V#d-W8"C0}e{fsp2e'II^{~8*_!>8d#e#VR'}SW~W] GmCmv6QTh:5$96v{1N N*w"iS<ng5Iw>QZ.wvTa8eT\\,YY7Tra<hn~T^/6USzTp=%Hdl;~ac+gc_JwR?90FlZxk'           |$    IENDB`